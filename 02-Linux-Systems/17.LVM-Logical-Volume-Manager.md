# MBR Limitations, System IDs, and LVM

In the previous section, we learned about MBR and GPT. While GPT is the modern standard, MBR is still everywhere. However, MBR has a major design flaw: it was built in the 1980s when nobody imagined a hard drive needing more than four sections.

This section explains how Linux gets around that limit using **Logical Partitions** and how to spot advanced storage systems like **LVM** (Logical Volume Manager).

---

## 1. The MBR Problem: The "Pizza Slice" Limit
The Master Boot Record (MBR) table has a hard limit: **It can only hold 4 entries.**
If you want to divide your disk into 6 parts (e.g., Boot, System, Data, Games, Backup, Swap), MBR physically cannot list them all.

### The Solution: Extended & Logical Partitions
To solve this, we use a trick called the **Extended Partition**.
1.  **Primary Partitions (1‚Äì4):** Standard partitions. You can have up to 4.
2.  **Extended Partition:** A special container. It takes up one "Primary" slot but acts like a wrapper.
3.  **Logical Partitions (5+):** Inside the Extended Partition, you can create as many sub-partitions as you want.

$$ \text{MBR Slot 1} \to \text{Primary (Win)} \\ \text{MBR Slot 2} \to \text{Primary (Linux)} \\ \text{MBR Slot 3} \to \text{Primary (Data)} \\ \text{MBR Slot 4} \to \underbrace{\textbf{Extended Container}}_{\text{Holds Logical 5, 6, 7...}} $$

*Note: In Linux, Primary partitions are numbered 1-4. Logical partitions always start at number 5.*

## 2. System IDs (The Hex Codes)
How does the computer know that Partition 1 is a "Linux Swap" area and Partition 2 is a "Windows" drive?
It uses a **System ID** (a Hexadecimal number).

*   **`83`**: Linux Filesystem (The standard).
*   **`82`**: Linux Swap (Virtual RAM).
*   **`8e`**: Linux LVM (Logical Volume Manager).
*   **`07`**: Windows NTFS.

**Crucial Difference:**
*   **`fdisk`:** Shows the raw **ID number** (e.g., `83`). It is the most accurate source of truth.
*   **`parted`:** Looks at the **Flag** or the filesystem content. It tries to be user-friendly ("ext4", "linux-swap").

## 3. Spotting LVM (Logical Volume Manager)
LVM is a layer of software that glues multiple hard drives together into one big "Volume Group."
When running `parted -l`, you can tell a system uses LVM if:
1.  **Flags:** You see the flag `lvm` on a physical partition.
2.  **Device Names:** You see paths like `/dev/mapper/ubuntu--vg-root` or `/dev/dm-0`.
3.  **Type:** The partition type code is `8e`.

---

# üõ†Ô∏è Hands-On Lab: GitHub Codespaces

We are going to push the limits of MBR. We will create a virtual drive, hit the 4-partition limit, use an Extended partition to break through it, and then assign different System IDs (Swap and LVM) to see how tools report them.

### Step 1: Create a MBR Disk
Create a blank 200MB file and attach it.

```bash
# Create file
dd if=/dev/zero of=mbr_test.img bs=1M count=200

# Attach to loop device
DISK=$(sudo losetup -fP --show mbr_test.img)

# Label it as MBR (msdos)
sudo parted $DISK mklabel msdos
```

### Step 2: Fill the Primary Slots (The Limit)
We will use `fdisk` to create partitions because it handles the Extended logic very clearly.

```bash
sudo fdisk $DISK
```
*(Follow these keystrokes exactly inside the interactive menu):*

1.  **`n`** (New partition) $\to$ **`p`** (Primary) $\to$ **`1`** $\to$ **`[Enter]`** $\to$ **`+10M`** (Partition 1)
2.  **`n`** (New partition) $\to$ **`p`** (Primary) $\to$ **`2`** $\to$ **`[Enter]`** $\to$ **`+10M`** (Partition 2)
3.  **`n`** (New partition) $\to$ **`p`** (Primary) $\to$ **`3`** $\to$ **`[Enter]`** $\to$ **`+10M`** (Partition 3)

*At this point, we have used 3 of the 4 slots.*

### Step 3: Create the Extended Container
Now we create the 4th partition, but we make it **Extended** so we can fit more inside.

4.  **`n`** (New partition)
5.  **`e`** (Select **Extended** instead of Primary)
6.  **`[Enter]`** (Default number 4)
7.  **`[Enter]`** (Start default)
8.  **`[Enter]`** (Use all remaining space)

*Now we have a container. Let's create Logical partitions inside it.*

9.  **`n`** (New) $\to$ **`[Enter]`** (Default starts at 5) $\to$ **`+10M`**
10. **`n`** (New) $\to$ **`[Enter]`** (Default starts at 6) $\to$ **`+10M`**

### Step 4: Change System IDs (Simulate Swap and LVM)
Let's mark Partition 1 as "Swap" and Partition 6 as "LVM".

11. **`t`** (Change type) $\to$ **`1`** (Partition 1) $\to$ **`82`** (Code for Swap)
12. **`t`** (Change type) $\to$ **`6`** (Partition 6) $\to$ **`8e`** (Code for LVM)
13. **`p`** (Print table to verify)
14. **`w`** (Write and Exit)

### Step 5: Compare `fdisk` vs `parted`
Now, let's look at how the two tools report our work.

**View 1: `fdisk` (The Raw Truth)**
```bash
sudo fdisk -l $DISK
```
**Observation:**
*   Look at the **Id** column. You will clearly see `82`, `83`, `5` (Extended), and `8e`.
*   Look at the **Device** names. Notice how it jumps from `p4` to `p5`.

**View 2: `parted` (The User Friendly View)**
```bash
sudo parted $DISK print
```
**Observation:**
*   `parted` doesn't show the Hex IDs (`82`, `8e`).
*   Instead, look at the **Type** column. It explicitly says `primary`, `extended`, and `logical`.
*   Look at the **Flags** column. Partition 6 should have the `lvm` flag.

### Step 6: Cleanup
```bash
sudo losetup -D
rm mbr_test.img
```

# Master Class: Modifying Partitions and Kernel Reloading

We are now moving from simply **viewing** partitions to **modifying** them. This is where things get dangerous but powerful. Here we cover three critical concepts:
1.  How to break the "4 Partition Limit" of MBR.
2.  The safety difference between `fdisk` and `parted`.
3.  How to force the Linux Kernel to notice your changes.

---

## 1. The MBR Logic: Primary, Extended, and Logical
As we discussed, MBR has a limit of **4 Primary Partitions**. If you want more, you must use a loophole called the **Extended Partition**.

Think of the hard drive like a filing cabinet with only **4 drawers**:
*   **Primary Partition:** A standard drawer. You open it, and your files are there.
*   **Extended Partition:** You remove one standard drawer and replace it with a **box**.
*   **Logical Partition:** Inside that box, you can put as many folders (Logical partitions) as you want.

**The Notation:**
The Kernel displays this nesting using angle brackets `< >`.
$$ \texttt{sda: sda1 sda2 < sda5 sda6 >} $$
*   `sda1`, `sda2`: Normal Primary partitions.
*   `< ... >`: This represents the Extended container (usually invisible to the user as storage).
*   `sda5`, `sda6`: These are the Logical partitions *inside* the container.

## 2. The Tool Showdown: `fdisk` vs. `parted`
This is the most important safety lesson in the chapter.

| Feature | **`fdisk`** (The Architect) | **`parted`** (The Construction Worker) |
| :--- | :--- | :--- |
| **Workflow** | You draw a blueprint first. | You build immediately. |
| **Safety** | **High.** If you make a mistake, you can just quit (`q`) without saving. Nothing changes on the disk until you type `w` (write). | **Low.** As soon as you hit Enter on a command (like `mkpart`), the disk is physically changed. |
| **Undo?** | Yes, just exit without writing. | No, the partition is already gone/created. |

**Pro Tip:** Beginners should stick to `fdisk` because it gives you a "Undo" button (by simply quitting).

## 3. Waking Up the Kernel
When you write a new partition table, the change happens on the physical disk. However, the Linux Kernel (running in RAM) creates a map of the disk at boot time. It might not immediately know you changed the disk.

*   **The `fdisk` method:** When you type `w`, `fdisk` sends a specialized system call (signal) to the Kernel saying, *"Hey! I changed /dev/sda. Please re-read the table!"*
*   **The Manual method:** If the Kernel doesn't update (which happens if the disk is busy), you can force it using the command:
    $$ \texttt{blockdev --rereadpt /dev/sdX} $$

    ---

    # üõ†Ô∏è Hands-On Lab: GitHub Codespaces

    We will simulate a "Safe" failure (using `fdisk`'s safety features) and then perform a complex partitioning scheme involving Extended partitions to see how the Kernel reacts.

    ### Step 1: Prepare the Monitor
    We want to see the Kernel reacting to our changes in real-time.
    **Open a Second Terminal** and run:
    ```bash
    # Monitor kernel events regarding block devices
    udevadm monitor --kernel --subsystem-match=block
    ```
    *(Leave this running and switch back to Terminal 1)*.

    ### Step 2: Create a Dummy Drive
    In **Terminal 1**:
    ```bash
    # Create a 200MB file
    dd if=/dev/zero of=reload_test.img bs=1M count=200

    # Attach loop device
    DISK=$(sudo losetup -fP --show reload_test.img)
    echo "Working on: $DISK"
    ```

    ### Step 3: The "Safety" Test (Abort Changes)
    We will delete everything, but then "Abort" to prove `fdisk` is safe.

    1.  Start `fdisk`: `sudo fdisk $DISK`
    2.  Create a partition: Type `n`, `p`, `1`, `[Enter]`, `[Enter]`.
    3.  **STOP!** Do not type `w`.
    4.  Type `q` (Quit).

    **Observation:**
    *   Check Terminal 2 (Monitor). You will see **Zero** activity.
    *   Because we quit without writing, the Kernel was never bothered, and the disk was never touched.

    ### Step 4: Create Extended and Logical Partitions
    Now we do it for real. We will create 1 Primary and 1 Extended holding a Logical partition.

    1.  Start `fdisk`: `sudo fdisk $DISK`
    2.  **Primary:** `n` $\to$ `p` $\to$ `1` $\to$ `[Enter]` $\to$ `+50M`
    3.  **Extended:** `n` $\to$ `e` $\to`2` $\to$ `[Enter]` $\to$ `[Enter]` (Use rest of disk)
    4.  **Logical:** `n` $\to$ `[Enter]` (Defaults to 5) $\to$ `+50M`
    5.  **Write:** `w`

    **Observation:**
    *   **Look at Terminal 2:** As soon as you typed `w`, you should see a flurry of `change`, `add`, and `remove` events. This is `fdisk` signaling the kernel.
    *   You might see the kernel log mapping: `p1`, `p2 < p5 >`.

    ### Step 5: Verify with `/proc/partitions`
    This file contains the kernel's live memory of what disks exist.

    ```bash
    cat /proc/partitions | grep loop
    ```
    *   You will see the main loop device.
    *   You will see `p1` (Primary).
    *   You will see `p2` (The Extended Container - typically size 1K or similar).
    *   You will see `p5` (The Logical partition).

    ### Step 6: Force a Reload (The `blockdev` command)
    Sometimes, if a disk is busy, the Kernel ignores `fdisk`. We can force it to look again.

    ```bash
    sudo blockdev --rereadpt -v $DISK
    ```
    *   `-v` means verbose.
    *   **Look at Terminal 2:** You will see the events trigger again. This is how you "refresh" the system without rebooting!

    ### Step 7: Cleanup
    ```bash
    # Stop the monitor in Terminal 2 (Ctrl+C)
    # In Terminal 1:
    sudo losetup -D
    rm reload_test.img
    ```