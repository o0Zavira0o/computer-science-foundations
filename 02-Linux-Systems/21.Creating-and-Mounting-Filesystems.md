# Managing Linux Storage: Creating and Mounting Filesystems

## Introduction
Once a hard disk is partitioned (divided into slices), it is not yet ready to store files. It is simply a container of raw storage space. To make it usable, we must perform two critical steps:
1.  **Create a Filesystem:** This process (often called "formatting") draws the grid lines, creates the index, and prepares the structure where data will live.
2.  **Mount the Filesystem:** This attaches the specific storage device to the main Linux directory tree so users can access it.

---

## Part 1: Creating a Filesystem (Formatting)

### 1.1 The `mkfs` Command
The command used to format a disk in Linux is `mkfs` (Make Filesystem). It is a user-space tool, meaning it runs as a normal program but interacts with the disk driver.

**The Syntax:**
$$ \texttt{mkfs -t [type] [device]} $$

*   **-t [type]:** Specifies the filesystem format (e.g., `ext4`, `xfs`, `vfat`).
*   **[device]:** The specific partition you want to format (e.g., `/dev/sda1`).

**Warning:** Running this command wipes all data on that specific partition. It creates a fresh, empty database structure.

### 1.2 The Wrapper Concept
Interestingly, `mkfs` is just a "front-end" or a manager. It doesn't know how to format every filesystem itself. Instead, it looks at the `-t` flag you provided and calls a specific helper program.

$$ \text{User calls: } \texttt{mkfs -t ext4} \rightarrow \text{System runs: } \texttt{mkfs.ext4} $$

Furthermore, many of these helper programs are just **Symbolic Links** (shortcuts) to a master utility. For the `ext` family (ext2, ext3, ext4), they all point to a tool called `mke2fs`.

### 1.3 The Superblock
When `mkfs` runs, it creates a **Superblock**. This is the most critical part of the filesystem. It contains the "metadata" of the drive:
*   How big the drive is.
*   How many files it can hold.
*   Where the free space is.

If the Superblock is corrupted, the drive becomes unreadable. Because it is so important, `mkfs` automatically writes copies (backups) of the superblock at different locations on the disk during formatting.

---

## Part 2: Hands-on Lab – Creating a Filesystem

In this example, we will create a virtual drive file, inspect the `mkfs` system, and then format our virtual drive.

### Step 1: Create a Virtual Raw Disk
We will create a 100MB empty file to act as our "partition."
```bash
dd if=/dev/zero of=my_data_disk.img bs=1M count=100
```

### Step 2: Inspect the `mkfs` Tools
Before we format, let's look at the "Wrapper" concept in action. We will list the files in the system binary directory to see the symbolic links.

```bash
ls -l /sbin/mkfs.*
```
**Observation:** Look at the output. You will likely see that `mkfs.ext4` points to (`->`) `mke2fs`. This confirms that `mkfs` is just delegating the work to `mke2fs`.

### Step 3: Format the Disk
Now, let's turn our raw zeros into a usable `ext4` filesystem.
*   `-F` is used here to force formatting on a file (usually it expects a real device like `/dev/sda`).

```bash
mkfs.ext4 -F my_data_disk.img
```
**Observation:** Read the output.
1.  It tells you it is creating a journal.
2.  It lists **Superblock backups** stored on blocks (e.g., 32768, 98304). These are the numbers you would save in a real recovery scenario.

---

## Part 3: Mounting the Filesystem

### 3.1 The Concept of Mounting
In Windows, if you plug in a drive, it gets a letter (D:, E:).
In Linux, there are no drive letters. There is only one big directory tree starting at Root (`/`).

**Mounting** is the act of taking a storage device and "gluing" it onto a specific folder in that tree. That folder is called the **Mount Point**.
*   The Mount Point must be an existing directory.
*   Any files previously inside that directory become invisible while the drive is mounted (so usually, we use empty directories).

### 3.2 The `mount` Command
To attach a drive, we use:
$$ \texttt{mount -t [type] [device] [mountpoint]} $$

*   **[type]:** (Optional) The filesystem type. Linux is usually smart enough to guess this.
*   **[device]:** The partition or file.
*   **[mountpoint]:** The folder where you want the data to appear.

To see what is currently mounted, simply type `mount` with no arguments.

### 3.3 Unmounting
To safely remove a drive, you must **unmount** it. This ensures all data is saved and written to the disk.
$$ \texttt{umount [mountpoint]} $$

---

## Part 4: Hands-on Lab – Mounting and Unmounting

We will now take the formatted `my_data_disk.img` from Part 2 and attach it to the system.

### Step 1: Create a Mount Point
We need a folder to act as the "door" to our disk.
```bash
mkdir my_storage_folder
```

### Step 2: Mount the Disk
We attach the disk image to the folder. We need `sudo` because this affects the system.
```bash
sudo mount my_data_disk.img my_storage_folder
```

### Step 3: Verify the Mount
Let's see if Linux recognizes it. We will use `mount` and filter for our folder name.
```bash
mount | grep my_storage_folder
```
**Observation:** You will see a line describing the mount. It will likely say `type ext4 (rw,...)`. This confirms it is mounted as Read/Write.

### Step 4: Write Data to the Disk
Now, anything we put inside `my_storage_folder` actually goes into `my_data_disk.img`.
```bash
# Create a file inside the mounted disk
sudo touch my_storage_folder/secret_plan.txt

# Verify it exists
ls -l my_storage_folder/
```

### Step 5: Unmount the Disk
We are done. Let's detach the disk.
```bash
sudo umount my_storage_folder
```

### Step 6: Verify Data Persistence
If we list the folder now, it should be empty (because the disk is unplugged).
```bash
ls -l my_storage_folder/
```
*Result: The folder is empty.*

But if we mount it again...
```bash
sudo mount my_data_disk.img my_storage_folder
ls -l my_storage_folder/
```
*Result: `secret_plan.txt` is back! The data is safely stored inside the image file.*

### Step 7: Clean Up
Always clean up your practice environment.
```bash
sudo umount my_storage_folder
rm my_data_disk.img
rmdir my_storage_folder
```