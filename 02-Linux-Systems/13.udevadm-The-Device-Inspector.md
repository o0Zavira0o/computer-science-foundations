# Deep Dive into `udevadm`: The Device Inspector

While `udevd` is the background worker managing devices, **`udevadm`** is your command-line interface to talk to it. Think of `udevadm` as the "Device Manager" or "Inspector" tool. It allows you to simulate events, reload rules, and‚Äîmost importantly‚Äîretrieve detailed "ID Cards" for every piece of hardware in your system.

---

## 1. The Purpose: Querying the Database
Linux tracks an immense amount of data for every device: physical path, serial numbers, voltage, partitions, and filesystem types.
The command `udevadm info` allows you to extract this hidden database. It is essential for writing `udev` rules because it tells you exactly what variable names (like `ID_SERIAL` or `DEVTYPE`) are available for you to match against.

## 2. The Command Syntax
To inspect a device, we use the `info` subcommand.
$$ \underbrace{\texttt{udevadm info}}_{Command} \quad \underbrace{\texttt{--query=all}}_{Scope} \quad \underbrace{\texttt{--name=/dev/sda}}_{Target} $$

*   **`udevadm info`:** "I want to look up information."
*   **`--query=all`:** "Show me everything you know (paths, symlinks, variables)."
*   **`--name=/dev/sda`:** "This is the specific device file I am asking about."

## 3. Decoding the Output (The ID Card)
When you run the command, you get a block of text where every line starts with a specific prefix letter. Here is how to read that secret code:

*   **`P:` (Physical Path in Sysfs)**
    *   *Example:* `/devices/pci0000:00/.../block/sda`
    *   *Meaning:* This is the strictly technical hardware address. It describes exactly which bus and port on the motherboard the device is plugged into.
*   **`N:` (Name)**
    *   *Example:* `sda`
    *   *Meaning:* This is the "Kernel Name." It is the fundamental filename the system uses.
*   **`S:` (Symlink)**
    *   *Example:* `disk/by-id/ata-WDC_WD3200...`
    *   *Meaning:* These are the "Friendly Shortcuts." `udev` created these so you can find the disk by its Serial Number instead of worrying if it is `sda` or `sdb`.
*   **`E:` (Environment)**
    *   *Example:* `ID_MODEL=Samsung_SSD_850`
    *   *Meaning:* These are **variables**. When writing `udev` rules, these are the exact keys you use to identify devices.

---

# üõ†Ô∏è Hands-On Lab: GitHub Codespaces

We will use `udevadm` to inspect the storage device that runs your Codespace environment. Since Codespaces are containers, the hard drive name might vary, so we will identify it first.

### Step 1: Identify Your Disk Name
Before we inspect a disk, we need to know what Linux calls it.

1.  **Run the list block devices command:**
    ```bash
    lsblk
    ```
2.  **Observation:**
    Look for the largest device. It is usually named `sda`, `vda`, or sometimes `nvme0n1`.
    *   If you see `sda`, we will use that.
    *   If you see `vda` (common in virtual machines), replace `sda` with `vda` in the next steps.

### Step 2: Run the Inspector
Let's assume your device is found at `/dev/vda` (or `/dev/sda`). We will ask `udevadm` to tell us everything about it.

```bash
# Replace /dev/vda with your actual disk name from Step 1
udevadm info --query=all --name=/dev/vda
```

**Observation:**
You will see a large output 
*   Look for lines starting with **`S:`**. Do you see `disk/by-uuid/...`? This is how Linux finds your boot drive even if the hardware changes slots.
*   Look for lines starting with **`E:`**. These are the environment details.

### Step 3: Filtering for Specific Data
The output is often too long. Let's say you are writing a rule and only care about the **Model Name** or **Serial Number**. We can combine `udevadm` with `grep`.

```bash
# Filter specifically for Model or Serial information
udevadm info --query=all --name=/dev/vda | grep -E "ID_MODEL|ID_SERIAL"
```

**Observation:**
The terminal returns only the clean variables, for example:
*   `E: ID_MODEL=Virtual_Disk`
*   `E: ID_SERIAL=0000001`
You now know exactly what text to copy-paste into a `.rules` file to target this specific drive!

### Step 4: Inspecting a "Fake" Device (Optional)
If you still have the `loop` device from the previous lab, you can inspect that too.

```bash
# Create a dummy loop device again if needed
dd if=/dev/zero of=test_card.img bs=1M count=10
sudo losetup -fP test_card.img

# Find the name (usually loop0)
losetup -a

# Inspect it
udevadm info --query=all --name=/dev/loop0
```
**Observation:**
Notice that `loop` devices have far fewer **`E:`** (Environment) variables than real physical disks because they don't have physical serial numbers or manufacturers!

### Step 5: Cleanup
```bash
# Remove the loop device if you created it
sudo losetup -D
rm test_card.img
```


# Real-Time Device Monitoring with `udevadm`

In the previous steps, we looked at static information. Now, we will look at **dynamic events**. The command `udevadm monitor` allows you to watch the conversation between the Linux Kernel and the `udev` daemon in real-time.

Think of this as an "Air Traffic Control" screen. You can see planes (devices) appearing on the radar (Kernel) and being assigned to gates (Udev).

---

## 1. The "Echo" Effect: Why Two Messages?
When you run the monitor and plug in a device, you will often see every event listed twice. This is not a bug; it is the two stages of the process.

1.  **KERNEL (The Raw Signal):**
    The Kernel says: *"I have detected a voltage change on the USB port. Something is here."*
    *   This happens first.
    *   It has no friendly names, just physical paths.
2.  **UDEV (The Processed Event):**
    The Daemon says: *"I received the Kernel's message. I have now applied the rules, assigned the group 'disk', and created the symlink 'my_backup_drive'."*
    *   This happens milliseconds later.

## 2. Filtering the Noise
On a busy server, thousands of events happen every minute. To make sense of the data, we use **filters**.

The syntax for filtering looks like this:
$$ \texttt{udevadm monitor} \quad \underbrace{\texttt{--kernel}}_{\text{Source}} \quad \underbrace{\texttt{--subsystem-match=scsi}}_{\text{Topic}} $$

*   **`--kernel` (or `-k`):** Only show me the raw hardware signals. Ignore the `udev` rule processing.
*   **`--udev` (or `-u`):** Only show me the final result after rules are applied.
*   **`--subsystem-match=...`:** Only show me specific types of hardware (e.g., `usb`, `scsi`, `block`, `net`).

## 3. A Note on `udisksd`
Let's  mention **`udisksd`**. While `udev` is the low-level plumber connecting pipes, `udisksd` is the high-level building manager.
*   **`udev`:** Creates the device file `/dev/sdb1`.
*   **`udisksd`:** Notices `/dev/sdb1` exists and automatically mounts it to `/media/user/MyDrive` so your graphical file explorer can see it.

---

# üõ†Ô∏è Hands-On Lab: GitHub Codespaces

We will simulate a hardware event and use `udevadm monitor` to catch it. We will try filtering to see the difference between raw Kernel signals and processed Udev events.

### Step 1: Open Two Terminals
To see this work, you need one terminal to **watch** and another terminal to **act**.
1.  In your VS Code / Codespaces, look at the terminal panel.
2.  Click the **`+`** icon (or Split Terminal icon) to open a second terminal window side-by-side.

### Step 2: Start the Monitor (Terminal 1)
In the **first** terminal, run the monitor. We will start by listening to *everything*.

```bash
udevadm monitor
```
*(The terminal will hang, waiting for input. It is now listening).*

### Step 3: Trigger an Event (Terminal 2)
In the **second** terminal, we will create a fake disk drive using the `loop` system.

```bash
# 1. Create a dummy file
dd if=/dev/zero of=monitor_test.img bs=1M count=10

# 2. Connect it to the system (This triggers the event!)
sudo losetup -fP monitor_test.img
```

**Observation (Look at Terminal 1):**
You should see a burst of text.
*   Lines starting with `KERNEL` (The simulated hardware connection).
*   Lines starting with `UDEV` (The system recognizing the loop device).

### Step 4: Test Filtering (Terminal 1)
Now, let's try to filter the output to be cleaner.
1.  Go to **Terminal 1**.
2.  Press `Ctrl+C` to stop the current monitor.
3.  Run this filtered command (we only want **Kernel** messages regarding **block** devices):

```bash
udevadm monitor --kernel --subsystem-match=block
```

### Step 5: Trigger Another Event (Terminal 2)
Go back to **Terminal 2** and remove the device we created.

```bash
# Remove all loop devices
sudo losetup -D
```

**Observation (Look at Terminal 1):**
*   This time, you will **only** see lines starting with `KERNEL`.
*   You will see the `remove` action.
*   You will **not** see the `UDEV` processing lines, making the logs much easier to read.

### Step 6: Cleanup
1.  Press `Ctrl+C` in Terminal 1 to stop the monitor.
2.  Remove the dummy file in Terminal 2:
    ```bash
    rm monitor_test.img
    ```