# Special-Purpose Filesystems and Memory Management (Swap)

## Introduction
In Linux, the concept of a "filesystem" goes beyond just storing documents and photos on a hard drive. Linux uses the filesystem structure (directories and files) as a universal interface to talk to the kernel, hardware, and running processes.

Additionally, we will look at **Swap Space**, which is a technique Linux uses to extend your computer's physical memory (RAM) using disk space.

---

## Part 1: Special-Purpose Filesystems

Most filesystems (`ext4`, `ntfs`) store data physically on a disk. **Special-Purpose Filesystems** are virtual. They are generated by the kernel on the fly. They don't take up space on your hard drive, but they look and act like normal files.

### 1.1 The `/proc` Filesystem (Process Information)
Mounted at `/proc`, this is the "Task Manager" of Linux, but in file form.
*   **Concept:** It allows you to see inside the kernel.
*   **Structure:** Every running program (Process) gets a numbered directory here (e.g., `/proc/1234`).
*   **Usage:** If you want to know what CPU your computer has, you don't call a special API; you just read a text file named `/proc/cpuinfo`.

### 1.2 The `/sys` Filesystem (System/Hardware)
Mounted at `/sys`, this creates a structured map of your hardware devices (USB, Hard Drives, Graphics cards). It helps the system organize how hardware is connected.

### 1.3 The `tmpfs` Filesystem (Temporary RAM Storage)
Mounted often at `/run` or `/dev/shm`.
*   **Concept:** This acts like a hard drive, but it actually stores data in your **RAM**.
*   **Speed:** It is incredibly fast because RAM is much faster than SSDs.
*   **Volatility:** If you reboot, everything in `tmpfs` vanishes.

### 1.4 SquashFS and OverlayFS
*   **SquashFS:** A read-only, highly compressed filesystem. It is used heavily in "Snap" packages. It squeezes a whole program into one file and mounts it so you can run it without unzipping it first.
*   **OverlayFS:** This stacks two filesystems on top of each other. Imagine a clear plastic sheet (Overlay) over a piece of paper (Base). You can write on the plastic without changing the paper underneath. This is the technology behind **Docker Containers**.

---

## Part 2: Swap Space

### 2.1 What is Swap?
Computers have a limited amount of RAM (Random Access Memory). If you open too many programs, RAM fills up.
Instead of crashing, Linux moves inactive parts of memory from the fast RAM to the slower Hard Disk. This reserved area on the disk is called **Swap**.

**The Memory Formula:**
$$ \text{Total Memory Available} = \text{Physical RAM} + \text{Swap Space} $$

### 2.2 Swap Partition vs. Swap File
There are two ways to create swap:
1.  **Swap Partition:** A dedicated slice of the hard drive formatted specifically for swap. This is done during OS installation.
2.  **Swap File:** A regular large file sitting inside your normal filesystem that acts as swap. This is more flexible because you can easily resize or delete it later.

---

## Part 3: Hands-on Lab (GitHub Codespaces)

In this lab, we will explore the virtual filesystems and then create a "Swap File" to extend our memory.

**Note:** GitHub Codespaces runs inside a Container. Some hardware-level commands (`swapon`) might be restricted by security policies, but we will go through the exact steps used on a real Linux server.

### Step 1: Explore `/proc` (The Kernel View)
Let's see how Linux exposes hardware info as text files.

```bash
# 1. Check CPU information
cat /proc/cpuinfo | grep "model name" | head -n 1

# 2. Check Memory information
# This is where the 'free' command actually gets its numbers!
grep MemTotal /proc/meminfo
```

### Step 2: Explore `/proc` (The Process View)
We will look at the current shell process. In Linux, `self` inside `/proc` is a magic link to the current running process.

```bash
# See the status of the current terminal process
cat /proc/self/status | head -n 5
```
**Observation:** You will see the `Name` (likely `bash`) and the `Pid` (Process ID).

### Step 3: Check Current Swap
We use the `free` command to check memory usage.

```bash
# -h means "Human Readable" (MB/GB instead of bytes)
free -h
```
**Observation:** Look at the **Swap** row. It might show `0B` if none is configured, or a number if the host system provided some.

### Step 4: Create a Swap File
We will create a 200MB file to use as extra memory.

```bash
# 1. Create a blank file filled with zeros
# if=input file, of=output file, bs=block size, count=number of blocks
dd if=/dev/zero of=my_swapfile bs=1M count=200

# 2. Verify the file exists and is 200MB
ls -lh my_swapfile
```

### Step 5: Format as Swap
We must tell Linux this is not just a data file, but a paging area.

```bash
# Set up the swap area
mkswap my_swapfile
```
**Observation:** It will output a UUID (e.g., `UUID=1234-abcd...`). This confirms the file is now formatted as swap.

### Step 6: Activate Swap (`swapon`)
*Note: This command requires `sudo`. In some containerized environments (like specific Codespaces configs), this might be blocked for security. If it says "Operation not permitted," it is a limitation of the cloud environment, but this is the correct command for a real server.*

```bash
# 1. Secure the file (Swap should only be readable by root)
chmod 600 my_swapfile

# 2. Turn it on
sudo swapon my_swapfile
```

### Step 7: Verify Activation
If the previous command succeeded, check the total memory again.

```bash
free -h
```
**Observation:** The number in the **Swap / Total** column should have increased by 200MB.

### Step 8: Making it Permanent (Concept)
If you reboot, this swap file turns off. To make it permanent on a real server, you would add it to `/etc/fstab`.

*Do not run this in Codespaces if you plan to keep the environment, but here is the command:*
```bash
# The syntax for /etc/fstab:
# /path/to/file  none  swap  sw  0  0
echo "/workspaces/codespaces-blank/my_swapfile none swap sw 0 0"
```

### Step 9: Remove Swap
When you no longer need the extra memory, you turn it off and delete the file.

```bash
# 1. Turn off the swap
sudo swapoff my_swapfile

# 2. Delete the file
rm my_swapfile

# 3. Check memory to confirm it is gone
free -h
```