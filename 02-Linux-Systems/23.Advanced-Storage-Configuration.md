# Advanced Storage Configuration: Mount Options, Remounting, and Persistence

## Introduction
In the previous sections, we learned the basics of mounting. However, real-world Linux administration requires more granular control. You may need to restrict permission to execute programs on a drive for security, change a drive from Read-Only to Read-Write without unplugging it, or ensure your drives mount automatically every time the computer turns on.

This guide covers **Long Options** (for fine-tuning), **Remounting** (live changes), and the **`/etc/fstab`** file (boot configuration).

---

## Part 1: Long Options
The standard short flags (like `-r` for read-only) are limited. Linux uses "Long Options" passed via the `-o` flag to provide advanced controls. You can combine multiple options by separating them with commas (no spaces).

**Syntax:**
$$ \texttt{mount -o option1,option2,option3 device mountpoint} $$

### Key Long Options
| Option | Description | Use Case |
| :--- | :--- | :--- |
| **`ro`** | **Read-Only**. (Same as `-r`). | Protecting backups or critical data from accidental deletion. |
| **`rw`** | **Read-Write**. (Default). | Standard operation. |
| **`exec`** | **Execute**. Allows programs to run. | Standard for system drives. |
| **`noexec`** | **No Execute**. Prevents programs/scripts from running. | Security. Used on data drives (like `/home` or USB sticks) to prevent malware from executing. |
| **`suid` / `nosuid`** | Controls **Set-UID** permissions. | Security. Prevents users from escalating privileges via files on this drive. |
| **`uid=1000`** | Force specific User ownership. | Used for non-Linux filesystems (like FAT/NTFS) that don't understand Linux permissions. |

---

## Part 2: Remounting
Sometimes you need to change the options of a drive that is *already* mounted.
**Scenario:** Your system crashes and boots in "Emergency Mode." The root drive is mounted Read-Only (`ro`) to prevent damage. You need to edit a config file to fix it.

Instead of unmounting (which stops the system), you **Remount**.

**Command:**
$$ \texttt{mount -o remount,rw /mountpoint} $$

This instantly updates the rules for that drive without interrupting active processes.

---

## Part 3: The `/etc/fstab` File
Manually mounting drives every time you restart the computer is tedious. Linux uses a configuration file located at `/etc/fstab` (**F**ile**S**ystem **TAB**le) to handle this automatically.

The system reads this file during boot. Each line represents a drive and consists of **6 columns**:

$$ \text{[Device]} \quad \text{[MountPoint]} \quad \text{[Type]} \quad \text{[Options]} \quad \text{[Dump]} \quad \text{[Fsck]} $$

1.  **Device:** The UUID (preferred) or device path (e.g., `/dev/sdb1`).
2.  **MountPoint:** Where the folder lives (e.g., `/home/data`).
3.  **Type:** Filesystem type (e.g., `ext4`, `xfs`, `swap`).
4.  **Options:** The long options discussed above (e.g., `defaults`, `noauto`, `errors=remount-ro`).
    *   `defaults`: A shortcut that enables `rw`, `exec`, `auto`, etc.
    *   `noauto`: Do *not* mount automatically at boot (good for USB drives).
    *   `user`: Allows a standard (non-root) user to mount this drive.
5.  **Dump:** Legacy backup setting. **Always set to 0**.
6.  **Fsck Order:** Determines if the system scans for errors at boot.
    *   `0`: Do not scan (used for swap, Windows drives, etc.).
    *   `1`: Root filesystem (scan first).
    *   `2`: All other Linux drives (scan second).

**The `mount -a` Command:**
    When you edit `/etc/fstab`, you don't need to reboot to test it. Running `sudo mount -a` tells Linux: *"Read the fstab file and mount anything that isn't currently attached."*

---

## Part 4: Hands-on Lab (GitHub Codespaces)

We will explore `noexec` for security, `remount` to change it live, and edit `/etc/fstab` to make it permanent.

### Step 1: Create a "Security Restricted" Drive
We will create a virtual drive and mount it with the `noexec` option. This means we can store scripts on it, but the system refuses to run them.

```bash
# 1. Create a 50MB disk image
dd if=/dev/zero of=secure_disk.img bs=1M count=50

# 2. Format as ext4
mkfs.ext4 -F secure_disk.img

# 3. Create a mount point
mkdir secure_data

# 4. Mount with 'noexec' (No Execution allowed)
# We use loop to treat the file as a block device
sudo mount -o loop,noexec secure_disk.img secure_data
```

### Step 2: Test the `noexec` Restriction
We will create a simple script and try to run it.

```bash
# 1. Create a simple script inside the drive
echo -e '#!/bin/bash\necho "If you see this, execution worked!"' > secure_data/test_script.sh

# 2. Make it executable (grant permission)
chmod +x secure_data/test_script.sh

# 3. Try to run it
./secure_data/test_script.sh
```
**Observation:** You should see: `bash: ./secure_data/test_script.sh: Permission denied`.
Even though you have permission (`chmod +x`), the *Mount Option* overrides it. This is how servers are secured.

### Step 3: Remount as Executable
Now, let's fix this without unmounting. We will change `noexec` to `exec` (or just defaults) using `remount`.

```bash
# Remount the current directory as Read-Write (rw) and Executable (exec)
sudo mount -o remount,rw,exec secure_data

# Verify the change
findmnt secure_data
```
Look for `exec` in the options column.

### Step 4: Run the Script
Now that we remounted, try running the script again.

```bash
./secure_data/test_script.sh
```
**Observation:** It works! Output: `"If you see this, execution worked!"`

### Step 5: Configure `/etc/fstab`
Now we will add this drive to the system configuration so it persists.
*Note: In Codespaces, we are root, but be careful editing fstab on real machines.*

1.  **Get the UUID** of our image (attached via loop):
    ```bash
    # Get the loop device name (e.g., /dev/loop0)
    LOOP_DEV=$(losetup -j secure_disk.img | cut -d: -f1)
                
    # Get the UUID
    DISK_UUID=$(blkid -s UUID -o value $LOOP_DEV)
    echo "Your UUID is: $DISK_UUID"
     ```

2.  **Add to `/etc/fstab`**:
    We will append a line. We need the full path of our `secure_data` directory.
    ```bash
    # Get full path of mount point
    MNT_PATH=$(realpath secure_data)
    
    # Create the config line
    # UUID | Path | Type | Options | Dump | Pass
    CONFIG_LINE="UUID=$DISK_UUID $MNT_PATH ext4 defaults 0 0"
    
    # Append to fstab (Using tee to write as sudo)
    echo "$CONFIG_LINE" | sudo tee -a /etc/fstab
    
    # Verify it is there
    tail -n 2 /etc/fstab
    ```
### Step 6: Test `mount -a`
To prove this works, we will unmount the drive, then ask Linux to read the configuration file.

```bash
# 1. Unmount the drive
sudo umount secure_data

# 2. Check: The folder should be empty
ls -l secure_data

# 3. Mount all from fstab
sudo mount -a

# 4. Check: The script should be back!
ls -l secure_data
```

### Step 7: Bonus - Line Endings (Unix vs DOS)
The text mentioned `\n` vs `\r\n`. Let's see the invisible characters.

```bash
# Create a Unix style file (Line Feed only)
printf "Hello Unix\n" > unix.txt

# Create a DOS style file (Carriage Return + Line Feed)
printf "Hello DOS\r\n" > dos.txt

# Use cat -A to show hidden characters
# $ means End of Line. ^M means Carriage Return.
echo "--- Unix File ---"
cat -A unix.txt

echo "--- DOS File ---"
cat -A dos.txt
```
**Observation:** The DOS file shows `^M$` at the end. This `^M` often causes errors in Linux scripts.

### Step 8: Clean Up
It is very important to remove the line from `/etc/fstab` in a lab environment to prevent errors next time the container starts (since the image file won't exist then).

```bash
# 1. Unmount
sudo umount secure_data

# 2. Remove the last line from /etc/fstab (The one we added)
# sed '$d' deletes the last line. -i means edit in-place.
sudo sed -i '$d' /etc/fstab

# 3. Delete files
rm secure_disk.img unix.txt dos.txt
rmdir secure_data
```