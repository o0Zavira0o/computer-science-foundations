# The Anatomy of Disk Access: Partitions and Layers

When you save a file in Linux, you aren't just throwing data onto a spinning platter. You are handing it off to a sophisticated assembly line of software layers.

This section breaks down **Partitions** (how we slice the pizza) and the **Kernel Hierarchy** (how the data travels from your text editor down to the hardware).

---

## 1. What is a Partition?
Imagine a hard drive is a large, empty warehouse.
*   **The Whole Disk (`/dev/sda`):** This is the entire building.
*   **Partitions (`/dev/sda1`, `/dev/sda2`):** These are the rooms you build inside the warehouse.
*   **Partition Table:** This is the blueprint hanging by the front door. It tells the Kernel exactly where the walls are located (e.g., "Room 1 starts at meter 0 and ends at meter 50").

### Why divide the disk?
1.  **Safety:** If you fill up your "Data Room" (`/home`) with movies, the "System Room" (`/`) still has space to breathe, so the computer doesn't crash.
2.  **Swap:** Linux uses a specific partition as "emergency RAM" (Swap space) when you run too many programs.
3.  **Booting:** Older computers needed specific small partitions at the start of the disk to launch the Operating System.

## 2. The Hierarchy of Access
How does data move? There are two distinct paths.

$$ \text{User App} \xrightarrow{\text{Request}} \text{Kernel} \xrightarrow{\text{Translation}} \text{Hardware} $$

### Path A: The "Filesystem" Route (Normal Use)
When you open a text file or save a picture, you use this path.
1.  **User Process:** Your text editor asks to save `notes.txt`.
2.  **Filesystem:** The database (like `ext4` or `xfs`) looks up where `notes.txt` lives. It says, "That file is in Partition 1, Block 500."
3.  **Block Interface:** The kernel calculates exactly where "Partition 1, Block 500" is on the physical disk.
4.  **SCSI Driver:** Sends the command to the hardware.

### Path B: The "Raw Device" Route (Admin Use)
Sometimes, you need to bypass the database.
1.  **User Process:** An admin tool (like `fdisk` or `dd`) asks to write directly to `/dev/sda1`.
2.  **Device Node:** The Kernel skips the filesystem logic entirely.
3.  **Block Interface:** It writes raw bytes directly to the partition.
    *   *Warning:* This is dangerous! If you write raw data over a filesystem, you might corrupt your files.

    ---

    # üõ†Ô∏è Hands-On Lab: GitHub Codespaces

    In this lab, we will become "Digital Architects." Since we cannot wipe the actual hard drive of the cloud server, we will create a **Virtual Hard Drive** (a file that acts like a disk), attach it to the kernel, slice it into partitions, and format them.

    ### Step 1: Create a "Virtual" Hard Disk
    We will create a 100MB file filled with zeros.
    ```bash
    # Create a 100MB empty file
    dd if=/dev/zero of=mydisk.img bs=1M count=100
    ```

    ### Step 2: Attach it to a Loop Device
    We tell the kernel: "Treat this file as if it were a physical hard drive plugged into a port."
    ```bash
    # Find the next available loop device and attach (-P scans for partitions)
    sudo losetup -fP --show mydisk.img
    ```
    *   **Observation:** The command will output a name, likely `/dev/loop0`. **Remember this name.** (I will assume `loop0` for the rest of the guide).

    ### Step 3: Create the Partition Table
    Now we will use `fdisk` to draw the blueprints. We will create two partitions on this disk.

    ```bash
    sudo fdisk /dev/loop0
    ```
    *(You are now inside the `fdisk` menu. Type the letters below exactly followed by Enter):*

    1.  **`n`** (New partition)
    2.  **`p`** (Primary)
    3.  **`1`** (Partition number 1)
    4.  **`[Enter]`** (Accept default first sector)
    5.  **`+50M`** (Make this partition 50 Megabytes)
    6.  **`n`** (New partition)
    7.  **`p`** (Primary)
    8.  **`2`** (Partition number 2)
    9.  **`[Enter]`** (Accept default first sector)
    10. **`[Enter]`** (Accept default last sector - uses remaining space)
    11. **`w`** (Write changes to disk and exit)

    ### Step 4: Verify the Layers
    Now that we have written the partition table, let's see how the Kernel views this new structure.

    ```bash
    lsblk /dev/loop0
    ```
    **Observation:**
    You should see a hierarchy (The "Partitions"):
    *   `loop0` (The Whole Disk - 100M)
        *   `‚îî‚îÄloop0p1` (Partition 1 - 50M)
            *   `‚îî‚îÄloop0p2` (Partition 2 - 48M)

            This proves the **Block Device Interface** has successfully mapped the partitions!

            ### Step 5: Add the Filesystem Layer
            Right now, the partitions are empty rooms. We need to put furniture (a database) in them so we can save files. We will use the `ext4` filesystem.

            ```bash
            # Format Partition 1
            sudo mkfs.ext4 /dev/loop0p1

            # Format Partition 2
            sudo mkfs.ext4 /dev/loop0p2
            ```

            ### Step 6: Mount and Use (The Top Layer)
            Finally, we connect these partitions to a folder so your User Processes can access them.

            ```bash
            # Create directories (Mount points)
            mkdir part1 part2

            # Mount the partitions
            sudo mount /dev/loop0p1 part1
            sudo mount /dev/loop0p2 part2

            # Write a file (User Process -> Filesystem -> Block Layer -> Disk)
            echo "Hello World" > part1/hello.txt

            # Verify
            ls -l part1/
            ```

            ### Step 7: Cleanup
            Always clean up your virtual lab.
            ```bash
            # Unmount
            sudo umount part1 part2
            # Detach the loop device
            sudo losetup -D
            # Delete the file and folders
            rm mydisk.img && rmdir part1 part2
            ```

# Mastering Disk Partitioning: MBR, GPT, and Tools

In the previous step, we sliced a disk into partitions. Now, let's understand exactly **how** that information is stored. Just as a book has a "Table of Contents" at the front to tell you where chapters begin, a hard drive has a **Partition Table** at the very beginning of the disk.

This section explains the two competing standards for these tables (MBR vs. GPT) and the tools we use to read them.

---

## 1. The Battle of Standards: MBR vs. GPT
There is nothing magical about a partition table; it is just a small database written on the first few blocks of the drive. However, the format of that database matters.

### A. MBR (Master Boot Record)
*   **The Old Standard:** Dating back to the 1980s (DOS/Windows era).
*   **The Identifier:** Often called `msdos` label in Linux tools.
*   **Limitations:**
    *   Max Disk Size: 2 Terabytes (It physically cannot count higher).
    *   Max Primary Partitions: 4.
    *   **No Names:** You cannot name a partition "System" or "Backup"; you only get numbers.

### B. GPT (GUID Partition Table)
*   **The Modern Standard:** Part of the UEFI standard used by modern PCs and Macs.
*   **The Identifier:** Called `gpt` label.
*   **Advantages:**
    *   Max Disk Size: Zettabytes (Effectively unlimited).
    *   Max Partitions: 128 (default), but can go higher.
    *   **Names:** You can give partitions text labels (e.g., "Windows", "Recovery", "Data").

## 2. The Toolbelt: `fdisk` vs. `parted`
Linux provides two main command-line tools to manage these tables.

| Feature | **`fdisk`** | **`parted`** |
| :--- | :--- | :--- |
| **Style** | Interactive Menu (press 'm' for help) | Command Line (or interactive mode) |
| **Safety** | **Safe.** Changes are in memory until you type `w` (write). | **Instant.** Changes happen immediately. |
| **Strengths** | Great for creating/editing. "Try before you buy." | Great for scripting and **viewing** details. |

$$ \text{Advice: Use } \texttt{parted} \text{ to look, use } \texttt{fdisk} \text{ to touch.} $$

## 3. Partitioning $\neq$ Formatting
A crucial concept:
1.  **Partitioning:** Drawing the lines on the floor plan. "This room is the kitchen."
2.  **Formatting (Filesystem):** Installing the shelves and cabinets. "This kitchen uses IKEA cabinets (ext4)."

Tools like `fdisk` and `parted` **only** build the walls. They do not format the disk. We use other tools (like `mkfs`) for formatting later.

---

# üõ†Ô∏è Hands-On Lab: GitHub Codespaces

We will create two virtual hard drives. We will format one using the old MBR standard and the other using the modern GPT standard, then compare them using `parted` to see the differences.

### Step 1: Create Two Virtual Disks
We will create two small 100MB files to act as our hard drives.

```bash
# Create the files
dd if=/dev/zero of=disk_mbr.img bs=1M count=100
dd if=/dev/zero of=disk_gpt.img bs=1M count=100

# Attach them to loop devices
# We capture the output name into variables to make it easier
LOOP_MBR=$(sudo losetup -fP --show disk_mbr.img)
LOOP_GPT=$(sudo losetup -fP --show disk_gpt.img)

echo "MBR Disk is: $LOOP_MBR"
echo "GPT Disk is: $LOOP_GPT"
```

### Step 2: Apply Partition Tables (Labels)
We will use `parted` to "stamp" the empty disks with a specific table type.

```bash
# Label the first disk as MSDOS (MBR)
sudo parted $LOOP_MBR mklabel msdos

# Label the second disk as GPT
sudo parted $LOOP_GPT mklabel gpt
```

### Step 3: Create Partitions
Now we create a partition on each. Notice how GPT allows us to provide a **Name**.

```bash
# Create a partition on MBR (No name allowed, just type/size)
sudo parted $LOOP_MBR mkpart primary ext4 1MB 50MB

# Create a partition on GPT (Notice the name "MyData"!)
sudo parted $LOOP_GPT mkpart "MyData" ext4 1MB 50MB
```

### Step 4: The Inspection (`parted -l`)
The `-l` flag stands for "list". It scans all disks and prints their details.

```bash
sudo parted -l
```

**Observation:**
Look carefully at the output (it will show your container's main disk first, scroll down to find your loop devices).

**For the MBR Disk:**
*   `Partition Table: msdos`
*   You will see Number, Start, End, Size, Type, File system, Flags.
*   *Missing:* There is no "Name" column.

**For the GPT Disk:**
*   `Partition Table: gpt`
*   You will see an extra column: **Name**.
*   You should see the string "MyData" in that column.

This matches the distinction made in Figure 4.1.1 of your text!

### Step 5: The `fdisk` View
Let's see how `fdisk` displays the GPT disk differently.

```bash
sudo fdisk -l $LOOP_GPT
```

**Observation:**
*   `Disklabel type: gpt`
*   It shows precise "Sectors" (units of 512 bytes).
*   The text noted that `fdisk` gives exact numbers, while `parted` approximates (e.g., "50MB").

### Step 6: Cleanup
```bash
sudo losetup -D
rm disk_mbr.img disk_gpt.img
```