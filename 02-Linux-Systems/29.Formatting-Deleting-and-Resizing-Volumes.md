# Mastering LVM: Formatting, Deleting, and Resizing Volumes

## Introduction
Once you have created Logical Volumes (LVs), they act just like physical hard drive partitions. To use them, you must:
1.  **Format** them with a filesystem (like ext4).
2.  **Mount** them to a directory.

The true power of LVM, however, lies in its flexibility. If you realize you made a volume too small, or you have an old volume you don't need, you can delete and resize them **while the system is running**.

In this guide, we will walk through the lifecycle of a Logical Volume: **Create $\rightarrow$ Format $\rightarrow$ Delete (unused ones) $\rightarrow$ Resize (grow).**

---

## Part 1: Using the Logical Volume (Formatting)

After running `lvcreate`, you have a "raw" block device. You cannot save files to it yet. You must apply a filesystem.

**The Path:**
LVM creates user-friendly shortcuts for your devices. You can use either:
*   `/dev/mapper/VolumeGroup-LogicalVolume`
*   `/dev/VolumeGroup/LogicalVolume`

**The Command:**
$$ \texttt{mkfs -t ext4 [Path to LV]} $$

---

## Part 2: Removing a Logical Volume

If a volume is no longer needed, you can delete it to reclaim space.

**The Command:**
$$ \texttt{lvremove VolumeGroup/LogicalVolume} $$

### **CRITICAL WARNING: SYNTAX MATTERS**
When typing the removal command, you should use a **slash** (`/`) between the Group name and Volume name.

*   **Safe:** `lvremove myvg/myvol` (Deletes only `myvol`).
*   **Dangerous:** `lvremove myvg myvol` (Deletes `myvol` **AND** tries to delete the entire `myvg` group).

Always check the prompt before typing `y`!

---

## Part 3: Resizing Volumes (The Manual Way)

Resizing involves two distinct layers:
1.  **The Container (LVM):** You must make the logical partition bigger.
2.  **The Contents (Filesystem):** You must stretch the ext4 filesystem to fill the new container.

If you do this manually, you run two commands:
1.  `lvresize -l +[Extents] [Path]`: Extends the LVM boundary.
2.  `resize2fs [Path]` (or `fsadm`): Stretches the filesystem to fit.

---

## Part 4: Resizing Volumes (The Easy Way)

Modern LVM tools allow you to do both steps in a single command using the `-r` (resize filesystem) flag. You can also use percentage logic like `+100%FREE` to use up all remaining space.

**The Magic Command:**
$$ \texttt{lvresize -r -l +100\%FREE [Path]} $$

---

## Part 5: Hands-on Lab (GitHub Codespaces)

In this lab, we will simulate a full workflow. We will create a "disk," split it into two volumes, format them, delete one, and expand the other to take over the free space.

**Note:** Run these commands as `root` (use `sudo`).

### Step 1: Setup the Environment
We create a 300MB virtual disk, a Volume Group (`lab_vg`), and two volumes (`vol_1` and `vol_2`).

```bash
# 1. Create a 300MB file
dd if=/dev/zero of=lvm_practice.img bs=1M count=300

# 2. Attach loop device
LOOPDEV=$(sudo losetup -fP --show lvm_practice.img)

# 3. Create PV and VG
sudo pvcreate $LOOPDEV
sudo vgcreate lab_vg $LOOPDEV

# 4. Create two volumes (50MB each)
sudo lvcreate -L 50M -n vol_1 lab_vg
sudo lvcreate -L 50M -n vol_2 lab_vg

# 5. Check status
sudo lvs
```

### Step 2: Format and Mount `vol_1`
We will put a filesystem on `vol_1` and mount it so we can see the size.

```bash
# 1. Format with ext4
sudo mkfs -t ext4 /dev/lab_vg/vol_1

# 2. Create mount point
mkdir mnt_point

# 3. Mount it
sudo mount /dev/lab_vg/vol_1 mnt_point

# 4. Check the size
df -h mnt_point
```
**Observation:** usage should be around **45-50MB**.

### Step 3: Remove `vol_2`
We decided we don't need `vol_2`. Let's delete it.

```bash
# Syntax: lvremove Group/Volume
sudo lvremove lab_vg/vol_2
```
*Type `y` if asked to confirm.*

### Step 4: Resize `vol_1` (The Manual Method)
We will add 20MB to `vol_1` manually.
*Note: We are resizing while the disk is still mounted! This is called "Online Resizing."*

```bash
# 1. Extend the LVM container by 20MB
sudo lvresize -L +20M /dev/lab_vg/vol_1

# 2. Check disk space (df)
df -h mnt_point
```
**Observation:** Wait! The size in `df` didn't change?
**Reason:** We made the container bigger, but the filesystem inside is still small.

```bash
# 3. Resize the filesystem to fill the container
sudo resize2fs /dev/lab_vg/vol_1

# 4. Check disk space again
df -h mnt_point
```
**Observation:** Now the size has increased (approx 70MB).

### Step 5: Resize `vol_1` (The Easy Method)
Now we want `vol_1` to take up **all** the remaining space in the Volume Group (including the space freed by deleting `vol_2`). We will use the `-r` flag to handle the filesystem automatically.

```bash
# -r : Resize filesystem automatically
# -l +100%FREE : Add 100% of the remaining free space
sudo lvresize -r -l +100%FREE /dev/lab_vg/vol_1
```

### Step 6: Verify Final Result
```bash
# Check the mount point size
df -h mnt_point

# Check LVM details
sudo lvs
```
**Observation:** `vol_1` should now be nearly **300MB** (the full size of our virtual disk).

### Step 7: Clean Up
Always clean up your lab.

```bash
# 1. Unmount
sudo umount mnt_point

# 2. Remove LVs and Group
sudo lvremove -y lab_vg/vol_1
sudo vgremove lab_vg
sudo pvremove $LOOPDEV

# 3. Detach and delete file
sudo losetup -d $LOOPDEV
rm lvm_practice.img
rmdir mnt_point
```

So far, we have used LVM commands like `pvcreate` and `lvcreate` to manage storage. But how does Linux actually perform the magic of resizing partitions while the system is running?

The answer lies in a split architecture:
1.  **User Space (The Brain):** The tools you type (`lvm`, `pvs`, `lvs`). They scan disks and read "metadata" headers to understand the layout.
2.  **Kernel Space (The Muscle):** A component called the **Device Mapper**. It does the heavy lifting of redirecting data traffic from a virtual "Logical Volume" to the actual "Physical Hard Drive."

---

## Part 1: User Space (Scanning and Metadata)

The Linux Kernel does not automatically know which disks belong to which Volume Group. It relies on the user-space tools to figure that out.

### How LVM Scans
When you run a command like `pvscan` or `vgchange -a y` (activate), the tool performs these steps:
1.  **Scan:** It looks at every block device connected to the system.
2.  **Read Headers:** It reads the first few kilobytes of every disk looking for an **LVM Header**.
3.  **Group by UUID:** It groups disks together based on the unique IDs found in those headers.
4.  **Verify:** It checks if all pieces of the puzzle (all Physical Volumes) are present.
5.  **Instruct:** If everything looks good, it sends instructions to the **Kernel** to build the map.

### The LVM Header
Every Physical Volume has a specific area at the start of the disk reserved for text-based metadata. This text describes the Volume Group name, the Logical Volumes inside it, and their sizes.

---

## Part 2: Kernel Space (The Device Mapper)

Once the tools figure out the layout, they hand the job over to the **Device Mapper** (*devmapper*).

### What is the Device Mapper?
The Device Mapper is a driver in the Linux Kernel. It sits between the Filesystem (where your files are) and the Physical Disk.
It acts like a **GPS redirection service**:
*   **Request:** The filesystem asks to write data to "Sector 100 of Logical Volume A."
*   **Translation:** The Device Mapper looks at its table and says, "Logical Sector 100 is actually located at Physical Sector 5000 on Disk /dev/sdb."
*   **Action:** It writes the data to the physical disk.

### The Control File
The LVM tools talk to the kernel driver using a special file located at:
$$ \texttt{/dev/mapper/control} $$
They use a system call named `ioctl` (Input/Output Control) to send mapping tables to the kernel via this file.

---

## Part 3: The `dmsetup` Utility

While `lvm` is the high-level tool for humans, `dmsetup` is the low-level tool that talks directly to the Device Mapper. It allows you to see exactly what the kernel sees.

When you run `dmsetup info`, you see the **Major and Minor** numbers.
*   **Major Number:** Usually **253** for device mapper devices.
*   **Minor Number:** Increases for every volume you create (0, 1, 2...).

This explains why the real device files in `/dev/` are often named `dm-0`, `dm-1`, etc.

---

## Part 4: Hands-on Lab (LVM Internals)

In this lab, we will build a small LVM setup, then "hack" into the raw disk to read the metadata text manually, and finally inspect the kernel driver's view.

**Note:** Run these commands as `root` (use `sudo`).

### Step 1: Build a Mini LVM System
We need a live LVM setup to inspect.

```bash
# 1. Create a 100MB virtual disk
dd if=/dev/zero of=lvm_internals.img bs=1M count=100

# 2. Setup Loop device
LOOPDEV=$(sudo losetup -fP --show lvm_internals.img)

# 3. Initialize LVM
sudo pvcreate $LOOPDEV
sudo vgcreate internal_vg $LOOPDEV
sudo lvcreate -L 50M -n internal_lv internal_vg
```

### Step 2: Read the Raw Metadata (`dd` + `strings`)
LVM writes its configuration in plain text at the start of the disk. We can read it using `dd` (to grab the first part of the disk) and `strings` (to filter out binary garbage and show only text).

```bash
# Read the first 1MB of the disk and look for readable text
# We grep for "internal" to find our specific group config
sudo dd if=$LOOPDEV count=1 bs=1M 2>/dev/null | strings | grep -C 5 "internal_vg"
```
**Observation:**
You should see a structure resembling code (JSON/XML style). You will see:
*   `id = "..."` (The UUID)
*   `internal_vg { ... }` (The group definition)
*   `internal_lv { ... }` (The volume definition)
*   `segment1 { start_extent = 0 ... }` (The mapping).

This proves that LVM configuration is just text written to the hard drive header!

### Step 3: Inspect the Device Mapper (`dmsetup`)
Now let's see what the Kernel sees.

```bash
# List all mapped devices
sudo dmsetup ls
```
*Result:* You should see `internal_vg-internal_lv`.

Now let's get the technical info:
```bash
# Get detailed info
sudo dmsetup info internal_vg-internal_lv
```

**Analyze the Output:**
1.  **Name:** `internal_vg-internal_lv`
2.  **State:** `ACTIVE` (The kernel is ready to use it).
3.  **Major, minor:** You will see numbers like `253, 0`.
    *   Check this against the directory listing:
    ```bash
    ls -l /dev/dm-*
    ```
    You will see the device `dm-0` has the exact same major/minor numbers.

### Step 4: The Mapping Table
We can ask the kernel: *"Where does this volume actually live physically?"*

```bash
sudo dmsetup table internal_vg-internal_lv
```
**Output Explanation:**
It will look like: `0 102400 linear 7:0 2048`
*   **0:** Start sector of the logical volume.
*   **102400:** Length (in sectors).
*   **linear:** The type of mapping (direct).
*   **7:0:** The Major:Minor number of the **Physical Disk** (loop0).
*   **2048:** The offset (where the data starts on the physical disk).

### Step 5: Clean Up
Remove the complex layers we created.

```bash
# 1. Remove LVM components
sudo lvremove -y internal_vg/internal_lv
sudo vgremove internal_vg
sudo pvremove $LOOPDEV

# 2. Detach loop device
sudo losetup -d $LOOPDEV

# 3. Delete file
rm lvm_internals.img
```


The Linux Kernel doesn't natively "understand" LVM Volume Groups. Instead, it relies on a subsystem called the **Device Mapper**. LVM user tools (like `lvcreate`) calculate where data should go and hand a "map" to the kernel.

The command `dmsetup` allows us to read this map directly. It tells us exactly which physical hard drive sectors correspond to which logical volume sectors.

---

## Part 1: Understanding `dmsetup table`

When you run `dmsetup table`, you see raw mapping data. It looks cryptic, but it follows a strict format.

**Format:**
$$ \text{Name}: \quad \text{Start} \quad \text{Length} \quad \text{Type} \quad \text{SourceDevice} \quad \text{SourceOffset} $$

### Breakdown of Fields:
1.  **Name:** The mapper name (e.g., `myvg-mylv1`).
2.  **Start:** The logical sector where this segment begins (usually starts at 0).
3.  **Length:** How long this segment is (in 512-byte sectors).
4.  **Type:** Usually `linear` (direct mapping).
5.  **SourceDevice:** The Major:Minor ID of the physical disk (e.g., `8:17` for `/dev/sdb1`).
6.  **SourceOffset:** Where on the physical disk this data actually lives.

### The Concept of Linear Fragmentation
LVM prefers to keep data contiguous (all in one piece). However, if you create a Volume Group from two disks (one small, one large), and create a Logical Volume that is too big for a single disk, LVM **must** split it.

It creates a "Bridge":
*   **Segment 1:** Fills up the remainder of Disk A.
*   **Segment 2:** Spills over to start filling Disk B.

In the `dmsetup table`, this appears as **two separate lines** for the same Logical Volume.

---

## Part 2: Hands-on Lab (Visualizing the Map)

In this lab, we will create a scenario that forces LVM to split a volume across two "disks." Then we will inspect the kernel map to see the split.

**Note:** Run these commands as `root` (use `sudo`).

### Step 1: Create Two Uneven Virtual Disks
We will simulate:
*   **Disk A (Small):** 100 MB
*   **Disk B (Large):** 300 MB

```bash
# 1. Create the files
dd if=/dev/zero of=disk_small.img bs=1M count=100
dd if=/dev/zero of=disk_large.img bs=1M count=300

# 2. Attach loop devices
# We capture the output to variables for easy reference
SMALL_DEV=$(sudo losetup -fP --show disk_small.img)
LARGE_DEV=$(sudo losetup -fP --show disk_large.img)

# 3. Print the Major:Minor numbers
# We need these to understand the dmsetup table later!
ls -l $SMALL_DEV $LARGE_DEV
```
**Observation:** Look at the numbers after the group name (usually `root disk`). You might see something like `7, 0` or `7, 1`. These are the **Major:Minor** IDs. Remember which is Small and which is Large.

### Step 2: Create Volume Group
Combine them into `map_vg`.

```bash
# Initialize PVs
sudo pvcreate $SMALL_DEV $LARGE_DEV

# Create VG
sudo vgcreate map_vg $SMALL_DEV $LARGE_DEV
```

### Step 3: Create Logical Volumes
We will intentionally create specific sizes to force a split layout.
*   **LV1:** 200MB. (This fits easily inside the 300MB Large Disk).
*   **LV2:** 150MB. (Only 100MB remains on the Large Disk. It *must* spill over to the Small Disk).

```bash
# Create LV1 (200MB)
sudo lvcreate -L 200M -n lv_contiguous map_vg

# Create LV2 (150MB)
sudo lvcreate -L 150M -n lv_split map_vg
```

### Step 4: Inspect the Kernel Map (`dmsetup`)
Now, let's see the matrix.

```bash
sudo dmsetup table
```

**Analyze the Output:**
Look for lines starting with `map_vg`.

1.  **map_vg-lv_contiguous:**
    *   You should see **one line**.
    *   It fits entirely on one device (The Large Disk's Major:Minor ID).

2.  **map_vg-lv_split:**
    *   You should see **two lines**.
    *   **Line 1:** Starts at 0. Uses the remaining space of the Large Disk.
    *   **Line 2:** Starts where Line 1 ends. Uses the Small Disk's ID.

This proves that `lv_split` is physically fragmented across two drives, even though it looks like one drive to the OS.

### Step 5: Modify the Layout (Delete and Extend)
We will delete the split volume and expand the contiguous one to fill the gap.

```bash
# 1. Remove the fragmented volume
sudo lvremove -y map_vg/lv_split

# 2. Extend the first volume to take ALL space
# This will force it to claim the space on the Small Disk
sudo lvextend -l +100%FREE map_vg/lv_contiguous
```

### Step 6: Inspect the Map Again
```bash
sudo dmsetup table
```

**Analyze the Output:**
*   `map_vg-lv_contiguous` now has **two lines**.
*   **Line 1:** The original 200MB on the Large Disk.
*   **Line 2:** The new space appended from the Small Disk (or the freed space from the Large Disk).

LVM stitched the available blocks together to make one massive logical volume.

---

## Part 3: User Space vs. Kernel Space

This exercise highlights the architecture of Linux storage:

1.  **User Space (The Planner):**
    *   Tools: `fdisk`, `mkfs`, `lvm`, `pvcreate`.
    *   Role: These tools calculate sizes, read metadata headers, and decide *how* things should be organized. They do not move data; they just plan the architecture.

2.  **Kernel Space (The Worker):**
    *   Tools: `Device Mapper`, `block I/O`, `virtual memory`.
    *   Role: The kernel takes the "Plan" (the mapping table) and actually routes the electricity to the correct sectors on the hardware.

In your daily life, you interact with User Space tools to configure the system, but the Kernel handles the heavy lifting of reading and writing files.

---

## Part 4: Clean Up
Remove the lab components.

```bash
# Remove LVM
sudo lvremove -y map_vg/lv_contiguous
sudo vgremove map_vg
sudo pvremove $SMALL_DEV $LARGE_DEV

# Detach Loops
sudo losetup -d $SMALL_DEV
sudo losetup -d $LARGE_DEV

# Delete files
rm disk_small.img disk_large.img
```