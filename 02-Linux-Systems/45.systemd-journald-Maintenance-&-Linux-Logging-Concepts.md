## systemd-journald Maintenance & Linux Logging Concepts (Syslog vs journald)

---

## 1) Journal Maintenance: how `journald` “rotates” without `logrotate`

### 1.1 Where persistent journals live

On many systems, persistent journals are stored under:

```bash
/var/log/journal
```


If persistent storage isn’t enabled, logs may be stored only in volatile memory (typically under `/run/log/journal`) and disappear after reboot.

### 1.2 Check whether your journal is persistent

Run:

```bash
ls -ld /var/log/journal /run/log/journal
```

**Interpretation**

* If `/var/log/journal` exists and contains directories, you likely have **persistent** logs.
* If it doesn’t exist but `/run/log/journal` does, you likely have **volatile** logs.

---

## 2) See what `journald` is configured to keep (space, size, age rules)

All journal retention rules are controlled by `journald.conf` (and drop-ins), and you can inspect the effective settings.

### 2.1 Show current `journald` disk-usage and limits

```bash
journalctl --disk-usage
```

This reports how much disk space the journal currently uses.

### 2.2 Display the effective journald configuration

A very useful command is:

```bash
systemd-analyze cat-config systemd/journald.conf
```

This prints:

* the main config file (if present)
* any override “drop-in” files (most distros use these)
* the effective values after merging

**What to look for (common keys)**

* `Storage=` (e.g., `auto`, `persistent`, `volatile`)
* `SystemMaxUse=` (max total journal size)
* `SystemKeepFree=` (space to keep free on filesystem)
* `SystemMaxFileSize=` (cap per journal file)
* `MaxRetentionSec=` (maximum age retention, if set)
* `MaxFileSec=` (time-based file rotation, if set)

---

## 3) Hands-on: safely test and observe journal cleanup behavior

> These exercises let you *see* journald maintenance mechanisms directly.

### Exercise A — Measure journal growth, then generate your own logs

**Step 1: Record current journal size**

```bash
journalctl --disk-usage
```

**Step 2: Create a burst of log messages (safe, user-level)**
Use `systemd-cat` to send messages into journald:

```bash
for i in $(seq 1 200); do
  echo "training-log message $i $(date -Is)" | systemd-cat -t training-log -p info
done
```

* `-t training-log` sets an identifier you can search for
* `-p info` sets priority

**Step 3: Confirm they arrived**

```bash
journalctl -t training-log -n 20
```

**Step 4: Re-check size**

```bash
journalctl --disk-usage
```

You should usually see journal size increase (even if slightly).

---

### Exercise B — Vacuum (cleanup) old entries by *size* (immediate effect)

`journald` can delete old journal data on demand.

**Step 1: Note current size**

```bash
journalctl --disk-usage
```

**Step 2: Vacuum to a target size (example: 50M)**

```bash
sudo journalctl --vacuum-size=50M
```

**Step 3: Confirm new size**

```bash
journalctl --disk-usage
```

What you’re seeing is **journald’s own maintenance** removing older chunks until the journal fits the requested limit.

---

### Exercise C — Vacuum by *time* (age-based cleanup)

**Delete entries older than 1 day:**

```bash
sudo journalctl --vacuum-time=1d
```

You can try `2h`, `7d`, etc.

To see if it likely did anything, check:

```bash
journalctl --disk-usage
```

---

### Exercise D — Verify which storage mode you’re actually using

**Step 1: Inspect current runtime config**

```bash
systemctl show systemd-journald --property=StatusText
```

**Step 2: Check journald configuration again**

```bash
systemd-analyze cat-config systemd/journald.conf | sed -n '1,200p'
```

If you see `Storage=volatile`, then persistent storage may not be enabled.

---

## 4) A closer look at system logging (syslog + journald): the “why” and “how”

### 4.1 The syslog model (classic client–server)

Historically, applications wrote log messages to a syslog daemon via a Unix domain socket:

```bash
/dev/log
```

A syslog daemon (e.g., `rsyslogd`) could also listen on network sockets, enabling **centralized logging** (many machines sending logs to one server).

### 4.2 Syslog message classification: facility and severity

Syslog encodes a “priority” that combines:

* **Facility**: broad source category (kernel, mail, auth, daemon, local0–local7, etc.)
* **Severity**: urgency level (0–7)

Severity levels (common names):

$
\begin{aligned}
0 &: \text{emerg} \
1 &: \text{alert} \
2 &: \text{crit} \
3 &: \text{err} \
4 &: \text{warning} \
5 &: \text{notice} \
6 &: \text{info} \
7 &: \text{debug}
\end{aligned}
$

### 4.3 journald terminology difference

In journald/journalctl output, you’ll often see:

* **PRIORITY** = severity number (0–7)

So syslog’s “severity” is frequently called “priority” in the journald world.

---

## 5) Relationship between syslog and journald: why both still exist

### 5.1 Why syslog remains useful

* **Central aggregation across many machines** is a core syslog strength.
* Syslog daemons (like rsyslog) are modular and can output to:

  * text files
  * databases
  * remote collectors
  * even the journal format

### 5.2 journald’s strength

* Strong at collecting **a single machine’s logs** in a structured database-like store.
* systemd services’ stdout/stderr can be captured automatically into journald, increasing coverage beyond what apps send to syslog.

---

## 6) Hands-on: see syslog-style severity in journald (without repeating earlier tasks)

### Exercise E — Write logs at different severities and filter them

**Step 1: Emit one message per severity**

```bash
systemd-cat -t severity-demo -p emerg   echo "severity 0 emerg"
systemd-cat -t severity-demo -p alert   echo "severity 1 alert"
systemd-cat -t severity-demo -p crit    echo "severity 2 crit"
systemd-cat -t severity-demo -p err     echo "severity 3 err"
systemd-cat -t severity-demo -p warning echo "severity 4 warning"
systemd-cat -t severity-demo -p notice  echo "severity 5 notice"
systemd-cat -t severity-demo -p info    echo "severity 6 info"
systemd-cat -t severity-demo -p debug   echo "severity 7 debug"
```

**Step 2: Show them all**

```bash
journalctl -t severity-demo -n 50
```

**Step 3: Filter to “important only” (0..3)**

```bash
journalctl -t severity-demo -p 0..3 -n 50
```

You’ll see only emerg/alert/crit/err.

---

## 7) Trust and authenticity: why “trusted fields” matter

### 7.1 The problem

Classic syslog historically had weak/no authentication and no encryption by default. That meant:

* spoofing messages was easier
* network sniffing was possible on insecure links

Modern syslog deployments can use TLS and authenticated transport, but **verifying the true identity of an application** emitting a message is still hard.

### 7.2 journald’s mitigation

journald attaches trusted metadata (underscore fields), such as:

* `_PID`, `_UID`, `_COMM`
* `_SYSTEMD_UNIT`
* boot/session identifiers

These fields are harder for an ordinary client program to forge.

### Hands-on mini-demo: inspect trusted metadata for your generated logs

```bash
journalctl -t severity-demo -o json-pretty -n 1
```

Look for underscore fields like:
```bash
_PID,\ _UID,\ _COMM,\ _SYSTEMD_UNIT
```

This shows structured data journald maintains alongside the message.

---

## 8) Practical takeaway checklist

* Journald maintains its own “rotation” by enforcing size/space/age policies.
* You can **observe usage** with `journalctl --disk-usage`.
* You can **force cleanup** with:

  * `--vacuum-size=`
  * `--vacuum-time=`
* Syslog remains common for **centralized multi-host logging** and flexible outputs.
* journald excels at **single-host structured logging** and capturing service output automatically.

---
