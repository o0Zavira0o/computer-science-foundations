# The Universal Language of Disks: SCSI and the Linux Kernel

You might be wondering: *"My computer uses USB drives and SATA hard disks. Why are we talking about SCSI (Small Computer System Interface), a technology from the 1980s?"*

The answer is simple: **Standardization.**
While the physical cables have changed, the Linux Kernel still uses the **SCSI Language** to talk to almost all storage devices. Whether it is a USB stick, a SATA drive, or a DVD-ROM, Linux treats them as if they were SCSI devices.

---

## 1. The Addressing Scheme: `[H:C:T:L]`
In the Linux Kernel, every storage device has a specific numerical address, similar to an IP address for networking. This address is made of four numbers inside brackets, like `[2:0:0:0]`.

$$ \text{Address} = [ \underbrace{\texttt{Host}}_{Adapter} : \underbrace{\texttt{Channel}}_{Bus} : \underbrace{\texttt{Target}}_{ID} : \underbrace{\texttt{LUN}}_{Logic Unit} ] $$

1.  **Host (The Adapter):** This is the physical controller card (or chip) on your motherboard. If you have two USB controllers, you have Host 0 and Host 1.
2.  **Channel (The Bus):** Think of this as a cable coming out of the adapter.
3.  **Target (The Device ID):** The specific drive attached to that cable.
4.  **LUN (Logical Unit Number):** A sub-division inside the drive.
    *   *Real-world example:* Some USB card readers have slots for SD cards, MicroSD, and CompactFlash. The Reader is the **Target**, but the SD slot is **LUN 0** and the CF slot is **LUN 1**.

## 2. The Translation Layer
Your kernel creates a "Lie" to make life easier.
*   **Physical Reality:** You plug in a USB stick. It speaks the "USB Mass Storage" protocol.
*   **Kernel Reality:** Linux uses a translator (like `libata` for SATA or `usb-storage` for USB). It translates "SCSI Commands" into the specific electrical signals your device needs.

This is why your SATA hard drive appears as `/dev/sda` (**S**CSI **D**isk **A**), even though it isn't technically a legacy SCSI disk.

---

# üõ†Ô∏è Hands-On Lab: GitHub Codespaces

We will explore the SCSI subsystem. Because GitHub Codespaces runs inside a Container (Virtualization), the hardware we see is "Virtual," but the addressing logic remains the same.

### Step 1: Install `lsscsi`
The command `lsscsi` (List SCSI) is the standard tool for viewing this hierarchy. It is not installed by default in minimal environments.

```bash
sudo apt-get update && sudo apt-get install -y lsscsi
```

### Step 2: View the SCSI Devices
Run the command to see your storage devices arranged by their address.

```bash
lsscsi -s
```

**Observation:**
*   **If you see output:** It will look like this:
    ```text
    [0:0:0:0]    disk    Msft     Virtual Disk     1.0   /dev/sda   128GB
    [0:0:1:0]    cd/dvd  Msft     Virtual CD/ROM   1.0   /dev/sr0        -
    ```
    *   **`[0:0:0:0]`**: This is your main hard drive.
    *   **`disk`**: The type of device.
    *   **`/dev/sda`**: The device file name.

*   **If you see no output:** This is common in some Docker containers because they hide the "Physical" hardware from the container. In that case, we can verify the support differently in Step 3.

### Step 3: Check Sysfs (The Kernel's View)
Even if `lsscsi` is empty, we can look directly into the Kernel's directory to see if any SCSI "Hosts" (Virtual Controllers) exist.

```bash
ls /sys/class/scsi_host/
```

**Observation:**
You will likely see folders like `host0`, `host1`, etc.
*   These represent the virtual storage controllers assigned to your cloud instance.
*   Linux creates a `host` entry for every storage controller it detects during boot.

### Step 4: Compare with Block Devices
Let's cross-reference this with the block device list.

```bash
lsblk -S
```
*(The `-S` flag specifically asks for SCSI information).*

**Observation:**
This summarizes the Transport layer.
*   **HCTL:** This stands for Host:Channel:Target:LUN (the numbers we discussed).
*   **TYPE:** disk, rom, etc.
*   **VENDOR:** In a Codespace, this will likely say "Msft" (Microsoft) or "Virtual", proving that your "Hardware" is actually software emulating a SCSI disk!

### Step 5: Cleanup
We should remove the tool we installed to keep the environment clean.

```bash
sudo apt-get remove -y lsscsi
```

# Linux Kernel Architecture: The SCSI Layer Cake

How Linux manages the complexity of talking to thousands of different hard drives? It uses a **Three-Layer Architecture**.

Think of this like an international shipping company. The Headquarters (Kernel) issues orders in one standard language, but the delivery drivers (Hardware Drivers) in different countries need to translate those orders into local customs and road rules.

---

## 1. The Three Layers
The data flows vertically from the User/Kernel down to the physical hardware.

$$ \text{Top Layer} \xrightarrow{\text{SCSI Commands}} \text{Middle Layer} \xrightarrow{\text{Routing}} \text{Bottom Layer} \xrightarrow{\text{Electrical Signals}} \text{Hardware} $$

### Layer 1: The Top Layer (The "What")
*   **Role:** This layer decides *what* needs to happen (e.g., "Read 5KB of data").
*   **The Driver:** The most famous driver here is **`sd`** (**S**CSI **D**isk).
*   **Why it matters:** This driver creates the familiar files `/dev/sda` or `/dev/sdb`. It speaks the high-level SCSI language. It doesn't care if the disk is connected via USB, SATA, or Fiber Channel; it treats them all as "SCSI Disks."

### Layer 2: The Middle Layer (The Manager)
*   **Role:** This is the traffic cop.
*   **Function:** It takes the command from the Top Layer and figures out which specific bus (cable) the device is plugged into. It manages the queue of messages so data doesn't get lost.

### Layer 3: The Bottom Layer (The "How")
*   **Role:** This layer handles the translation to specific hardware protocols.
*   **The Translators:**
    *   **ATA Bridge (`libata`):** If you have a standard computer hard drive (SATA), this driver translates the SCSI command into an **ATA** command.
    *   **USB Bridge (`usb-storage`):** If you use a flash drive, this driver wraps the SCSI command inside a USB packet to send it over the USB cable.

## 2. Why "Translation" is Key
Another concept is **Bridges**. This is crucial. The Linux Kernel loves consistency. It wants to speak **one** language (SCSI).
Instead of rewriting the whole Kernel for every new type of hard drive, Linux just writes a small "Bottom Layer" driver that acts as a translator.
*   The Kernel says: "SCSI Write!"
*   The Bottom Layer says: "Wait, this is a USB stick. Let me translate that to USB signals."

---

# üõ†Ô∏è Hands-On Lab: GitHub Codespaces

We can use the terminal to see which drivers are currently handling your virtual hard drive. We will use a command that visualizes the "Topology" (the layers) of your storage.

### Step 1: View the Storage Topology
The `lsblk` command (List Block Devices) has a special flag `-t` for "Topology". This reveals the drivers operating at the bottom layers.

```bash
lsblk -t
```

**Observation:**
Look at the output columns:
*   **`NAME`**: The device name (e.g., `sda` or `vda`).
*   **`TRAN`**: The **Transport** type.
    *   If you see `sata`, the `libata` translator is working.
    *   If you see `usb`, the `usb-storage` translator is working.
    *   In Codespaces, you usually see `virtio` (Virtual I/O) because it is a cloud container, but the concept is the same: `virtio` is the "Bottom Layer" driver here!

### Step 2: Check Loaded Kernel Modules
We can ask the kernel specifically which "Layer 1" (Top Layer) drivers are currently loaded in memory.

```bash
# List modules and search for 'sd_mod' (SCSI Disk Module)
lsmod | grep sd_mod
```

**Observation:**
*   You should see `sd_mod`.
*   This confirms that even though you are in the cloud, the **Top Layer** driver described in your book is active and managing your storage!

### Step 3: Check for USB/SCSI Modules
Let's see if the "Bottom Layer" drivers are available in the kernel, even if not currently used by a physical USB stick.

```bash
# Check for usb storage or scsi specific modules
modinfo usb_storage | grep description
```

**Observation:**
*   You should see a description like: *"USB Mass Storage driver for Linux"*.
*   This proves that the code to perform the **SCSI $\to$ USB translation** sits inside your Linux kernel, ready to be used the moment a USB drive is plugged in (if it were a physical machine).

### Step 4: Trace the Driver Path (Advanced)
We can verify exactly which directory the device driver lives in.

```bash
# Replace 'sda' with 'vda' if that is your disk name
readlink /sys/class/block/sda/device/driver
```

**Observation:**
*   The output will show a path ending in `.../drivers/sd` (or `virtio-blk`).
*   This confirms that the device is indeed bound to the high-level **Disk Driver**.