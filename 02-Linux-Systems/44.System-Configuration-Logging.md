# System Configuration: Logging, Time, Scheduling, and Users

This guide introduces the fundamental building blocks of Linux system administration. We will focus on how Linux tracks events (Logging), manages time, schedules tasks, and organizes users. These are the core mechanisms that make the system usable for applications and administrators.

We will start with **System Logging**, specifically exploring the modern `journald` system and its interaction with legacy tools.

---

## **1. System Logging Overview**

When a program runs on Linux (like a web server, SSH daemon, or even the kernel), it needs a standardized way to report errors, warnings, and status updates. This is called **Logging**.

### **The Evolution of Logging**
1.  **Syslog (Legacy):** The traditional method. A daemon (`syslogd` or `rsyslogd`) listens for messages and writes them to text files in `/var/log/` (e.g., `/var/log/messages` or `/var/log/syslog`).
2.  **Journald (Modern):** Part of the `systemd` suite. It collects messages from the kernel, boot process, and services. It stores them in a **binary format** (not plain text) which allows for extremely fast indexing and searching.

Many modern systems run **both**: `journald` captures the message first, then forwards it to `rsyslogd` to write it to a text file for backward compatibility.

### **Anatomy of a Log Message**
A typical log line contains:
`Date Time Hostname Process[PID]: Message`

Example:
`Dec 14 17:59:48 duplex sshd[484]: Server listening on 0.0.0.0 port 22.`

---

## **2. Hands-on: Checking Your Log Setup**

Let's inspect what logging systems are active on your machine.

**Step 1: Check for Journald**
The easiest way is to try reading the journal.
```bash
journalctl -n 5
```
*   `-n 5`: Show only the last 5 lines.
*   *If you see output, journald is active.*

**Step 2: Check for Rsyslog**
Check if the traditional text-based logger is running.
```bash
systemctl status rsyslog
```
*   *Note: It might be called `syslog` on some Debian-based systems.*

**Step 3: Explore Log Files**
Look at the directory where text logs are stored.
```bash
ls -F /var/log/
```
*   Look for `syslog`, `messages`, `auth.log`, or `secure`.
*   Look for a directory named `journal/`. This is where `journald` keeps its persistent binary data.

---

## **3. Hands-on: Using `journalctl` (Searching & Monitoring)**

The `journalctl` command is your primary tool for investigating system issues. It reads the binary database and presents it as readable text.

### **Basic Viewing**
By default, it uses a "pager" (like `less`), so you can scroll up/down.
```bash
journalctl
```
*(Press `q` to exit).*

To see the newest messages first (reverse order):
```bash
journalctl -r
```

### **Filtering by Time**
This is arguably the most useful feature. You don't have to scroll through thousands of lines; just tell it *when* to look.

**Example 1: The last 1 hour**
```bash
journalctl -S -1h
```
*   `-S` stands for `--since`.

**Example 2: Since today started**
```bash
journalctl -S today
```

**Example 3: Specific Date and Time**
```bash
journalctl -S "2023-10-27 08:00:00" -U "2023-10-27 09:00:00"
```
*   `-U` stands for `--until`.

### **Filtering by Service**
You often only care about one specific application.

**Example 1: SSH Logs**
To see who logged into your system recently:
```bash
journalctl -u sshd
```
*   `-u`: Filter by **Unit** name.

**Example 2: Kernel Logs**
To see hardware or driver errors (like a USB drive failing):
```bash
journalctl -k
```
*   `-k`: Kernel messages only (similar to the old `dmesg` command).

### **Filtering by Priority (Severity)**
Logs have levels:
*   `0`: Emergency
*   ...
*   `3`: Error
*   `4`: Warning
*   ...
*   `7`: Debug

To see only Errors (level 3) and worse:
```bash
journalctl -p 3 -b
```
*   `-p`: Priority.
*   `-b`: Only show logs from the **current boot** (ignore logs from last week).

---

## **4. Real-time Monitoring (Follow)**

If you are debugging a service (e.g., trying to start a web server and it keeps failing), you want to see logs *as they happen*.

**Hands-on Example:**
1.  Open two terminal windows.
2.  **Terminal 1:** Run the "follow" command.
    ```bash
    journalctl -f
    ```
    *   `-f`: Follow (tail) the log.
3.  **Terminal 2:** Generate a log entry manually.
    ```bash
    logger "This is a test message from Terminal 2"
    ```
    *   The `logger` command sends a message to the system log.
4.  **Terminal 1:** Watch the message appear instantly.

---

## **5. Summary Table: `journalctl` Cheatsheet**

| Flag | Meaning | Example |
| :--- | :--- | :--- |
| **(none)** | Show all logs (oldest first) | `journalctl` |
| `-r` | Reverse (newest first) | `journalctl -r` |
| `-f` | Follow (live tail) | `journalctl -f` |
| `-n 20` | Show last 20 lines | `journalctl -n 20` |
| `-u service` | Filter by Unit | `journalctl -u nginx` |
| `-b` | Current Boot only | `journalctl -b` |
| `-k` | Kernel messages only | `journalctl -k` |
| `-S time` | Since time | `journalctl -S -10m` |
| `-p level` | Priority level | `journalctl -p err` |