# System Configuration: Logging, Time, Scheduling, and Users

This guide introduces the fundamental building blocks of Linux system administration. We will focus on how Linux tracks events (Logging), manages time, schedules tasks, and organizes users. These are the core mechanisms that make the system usable for applications and administrators.

We will start with **System Logging**, specifically exploring the modern `journald` system and its interaction with legacy tools.

---

## **1. System Logging Overview**

When a program runs on Linux (like a web server, SSH daemon, or even the kernel), it needs a standardized way to report errors, warnings, and status updates. This is called **Logging**.

### **The Evolution of Logging**
1.  **Syslog (Legacy):** The traditional method. A daemon (`syslogd` or `rsyslogd`) listens for messages and writes them to text files in `/var/log/` (e.g., `/var/log/messages` or `/var/log/syslog`).
2.  **Journald (Modern):** Part of the `systemd` suite. It collects messages from the kernel, boot process, and services. It stores them in a **binary format** (not plain text) which allows for extremely fast indexing and searching.

Many modern systems run **both**: `journald` captures the message first, then forwards it to `rsyslogd` to write it to a text file for backward compatibility.

### **Anatomy of a Log Message**
A typical log line contains:
`Date Time Hostname Process[PID]: Message`

Example:
`Dec 14 17:59:48 duplex sshd[484]: Server listening on 0.0.0.0 port 22.`

---

## **2. Hands-on: Checking Your Log Setup**

Let's inspect what logging systems are active on your machine.

**Step 1: Check for Journald**
The easiest way is to try reading the journal.
```bash
journalctl -n 5
```
*   `-n 5`: Show only the last 5 lines.
*   *If you see output, journald is active.*

**Step 2: Check for Rsyslog**
Check if the traditional text-based logger is running.
```bash
systemctl status rsyslog
```
*   *Note: It might be called `syslog` on some Debian-based systems.*

**Step 3: Explore Log Files**
Look at the directory where text logs are stored.
```bash
ls -F /var/log/
```
*   Look for `syslog`, `messages`, `auth.log`, or `secure`.
*   Look for a directory named `journal/`. This is where `journald` keeps its persistent binary data.

---

## **3. Hands-on: Using `journalctl` (Searching & Monitoring)**

The `journalctl` command is your primary tool for investigating system issues. It reads the binary database and presents it as readable text.

### **Basic Viewing**
By default, it uses a "pager" (like `less`), so you can scroll up/down.
```bash
journalctl
```
*(Press `q` to exit).*

To see the newest messages first (reverse order):
```bash
journalctl -r
```

### **Filtering by Time**
This is arguably the most useful feature. You don't have to scroll through thousands of lines; just tell it *when* to look.

**Example 1: The last 1 hour**
```bash
journalctl -S -1h
```
*   `-S` stands for `--since`.

**Example 2: Since today started**
```bash
journalctl -S today
```

**Example 3: Specific Date and Time**
```bash
journalctl -S "2023-10-27 08:00:00" -U "2023-10-27 09:00:00"
```
*   `-U` stands for `--until`.

### **Filtering by Service**
You often only care about one specific application.

**Example 1: SSH Logs**
To see who logged into your system recently:
```bash
journalctl -u sshd
```
*   `-u`: Filter by **Unit** name.

**Example 2: Kernel Logs**
To see hardware or driver errors (like a USB drive failing):
```bash
journalctl -k
```
*   `-k`: Kernel messages only (similar to the old `dmesg` command).

### **Filtering by Priority (Severity)**
Logs have levels:
*   `0`: Emergency
*   ...
*   `3`: Error
*   `4`: Warning
*   ...
*   `7`: Debug

To see only Errors (level 3) and worse:
```bash
journalctl -p 3 -b
```
*   `-p`: Priority.
*   `-b`: Only show logs from the **current boot** (ignore logs from last week).

---

## **4. Real-time Monitoring (Follow)**

If you are debugging a service (e.g., trying to start a web server and it keeps failing), you want to see logs *as they happen*.

**Hands-on Example:**
1.  Open two terminal windows.
2.  **Terminal 1:** Run the "follow" command.
    ```bash
    journalctl -f
    ```
    *   `-f`: Follow (tail) the log.
3.  **Terminal 2:** Generate a log entry manually.
    ```bash
    logger "This is a test message from Terminal 2"
    ```
    *   The `logger` command sends a message to the system log.
4.  **Terminal 1:** Watch the message appear instantly.

---

## **5. Summary Table: `journalctl` Cheatsheet**

| Flag | Meaning | Example |
| :--- | :--- | :--- |
| **(none)** | Show all logs (oldest first) | `journalctl` |
| `-r` | Reverse (newest first) | `journalctl -r` |
| `-f` | Follow (live tail) | `journalctl -f` |
| `-n 20` | Show last 20 lines | `journalctl -n 20` |
| `-u service` | Filter by Unit | `journalctl -u nginx` |
| `-b` | Current Boot only | `journalctl -b` |
| `-k` | Kernel messages only | `journalctl -k` |
| `-S time` | Since time | `journalctl -S -10m` |
| `-p level` | Priority level | `journalctl -p err` |

## Practical `journalctl` Filtering, Monitoring, and Log Rotation 
---

## 1) Filtering logs by **systemd unit** (`-u`)

### What a “unit” is

A **systemd unit** is a managed component such as a service (`.service`), timer (`.timer`), mount (`.mount`), etc. Many logs in the journal are tagged with the unit that produced them.

### Core command

```bash
journalctl -u cron.service
```

### You can usually omit `.service`

```bash
journalctl -u cron
```

> If `cron` isn’t present on your distro, try `crond`, `ssh`, `sshd`, `NetworkManager`, or list units first (next section).

### Hands-on exercise (works on almost any system)

1. **List active services** (not journal-specific, but helps you find a unit name):

```bash
systemctl list-units --type=service --state=running | head -n 20
```

2. Pick a service name you see (example: `ssh.service` or `systemd-journald.service`) and view its logs:

```bash
journalctl -u ssh
```

3. Add “this boot only” to reduce noise:

```bash
journalctl -u ssh -b
```

**What you should see:** log lines with timestamps, hostname, and the program/unit emitting messages.

---

## 2) If you don’t know the unit name: list units present in the journal (`-F _SYSTEMD_UNIT`)

### Why this helps

The journal stores many structured fields. `_SYSTEMD_UNIT` is one of them, and it tells you which unit a message belongs to.

### Command

```bash
journalctl -F _SYSTEMD_UNIT
```

### Hands-on: find a likely unit quickly

```bash
journalctl -F _SYSTEMD_UNIT | sort | head -n 30
```

Then copy one name and use it:

```bash
journalctl -u systemd-journald
```

---

## 3) Finding available fields (`-N`) and what “trusted fields” mean

### List all known fields in the journal

```bash
journalctl -N
```

### Trusted vs untrusted fields

Fields starting with an underscore (example: `_SYSTEMD_UNIT`) are **trusted** metadata added by the system/journal pipeline, not easily spoofed by normal applications.

* Trusted fields: begin with `_`
* Application-provided fields: typically do **not** begin with `_`

### Hands-on: spot trusted fields

```bash
journalctl -N | grep '^_'
```

---

## 4) Filtering by text using a regular expression (`-g`)

### What it does

`-g` searches messages by **regex** and returns only matching entries.

Example:

```bash
journalctl -g 'kernel.*memory'
```

This matches messages where `kernel` appears before `memory` in the same message.

### Important compatibility note

Some systems don’t build `journalctl` with regex support for `-g`.

### Hands-on: check if your `journalctl` supports `-g`

```bash
journalctl -g 'test' -n 1
```

* If it works: you’ll get either 0–1 matching lines (depending on your logs).
* If unsupported: you’ll see an error indicating `-g` isn’t available.

### If `-g` is not available: use `grep -E` as a fallback

```bash
journalctl | grep -E 'kernel.*memory'
```

### Getting surrounding context (very useful)

Regex filtering often hides nearby “cause” messages. A reliable approach is:

1. Find a matching line and note its timestamp.
2. Rerun with a start time just before that moment using `-S`.

Example pattern:

```bash
# Step 1: find a match and note the timestamp shown
journalctl -g 'kernel.*memory'

# Step 2: show a wider time window around the moment (edit the timestamp)
journalctl -S "2026-01-01 10:40:00" -U "2026-01-01 10:45:00"
```

---

## 5) Filtering by boot (`-b`), previous boots, and boot IDs

### Current boot only

```bash
journalctl -b
```

### Previous boot (offset `-1`)

```bash
journalctl -b -1
```

### List boots with IDs and ranges

```bash
journalctl --list-boots
```

You’ll see output shaped like:

* boot offset (e.g., `-1`, `0`)
* boot ID (a long hex-like string)
* time range

### Use a specific boot by offset or by ID

Offset form:

```bash
journalctl -b -1
```

Boot-ID form (copy the ID from `--list-boots`):

```bash
journalctl -b e598bd09e5c046838012ba61075dccbb
```

### Quick “did it shut down cleanly?” check (`-r` + `-b -1`)

`-r` reverses output (newest first), so you can quickly see how the last boot ended:

```bash
journalctl -r -b -1
```

**What you’re looking for:** clean shutdown messages near the end (top of reversed output), such as the journal stopping and shutdown sequence messages.

---

## 6) Kernel messages only (`-k`)

### Why use it

Kernel logs are frequently crucial for hardware, drivers, memory, filesystem, boot issues, etc.

### Command (current boot kernel messages)

```bash
journalctl -k
```

### Combine with boot filtering

Previous boot kernel messages:

```bash
journalctl -k -b -1
```

### Hands-on: make it easier to read

Show only the most recent 50 kernel lines:

```bash
journalctl -k -n 50
```

---

## 7) Filtering by severity/priority (`-p`)

### Priority levels

Systemd/journald priorities map to syslog-style levels:

[
0 ;(\text{most critical}) \rightarrow 7 ;(\text{least critical})
]

### Show everything up to a maximum severity

Example: show priorities (0) through (3) (critical → error):

```bash
journalctl -p 3
```

### Select a range only (`..` syntax)

Example: show only priorities (2) to (3):

```bash
journalctl -p 2..3
```

### Hands-on: see the difference

1. Show only high-severity items:

```bash
journalctl -p 0..3 -b
```

2. Show everything (likely much noisier):

```bash
journalctl -b
```

---

## 8) Real-time log monitoring (`-f`)

### What `-f` does

It “follows” the journal like `tail -f`, printing new entries as they arrive.

### Command

```bash
journalctl -f
```

### Hands-on: follow logs for a single unit (much cleaner)

Open one terminal and run:

```bash
journalctl -f -u ssh
```

Then, in a second terminal, **trigger activity** (choose one that exists on your system):

* If SSH server exists:

```bash
sudo systemctl restart ssh
```

* If it’s `sshd` instead:

```bash
sudo systemctl restart sshd
```

* Or use a broadly available unit:

```bash
sudo systemctl restart systemd-journald
```

Back in the `journalctl -f` terminal, you should see new log entries appear immediately.

Stop following with:

```bash
Ctrl+C
```

---

## 9) Log rotation with `logrotate` (traditional text log files)

### Why rotation exists

Plaintext logs in `/var/log` grow continuously. Rotation prevents them from consuming all disk space.

### The typical rotation idea (numbered files)

A common scheme looks like this:

* current: `auth.log`
* older: `auth.log.1`, `auth.log.2`, `auth.log.3`
* sometimes compressed: `auth.log.2.gz`, etc.

Rotation steps (conceptually):

1. delete oldest (`.3`)
2. rename `.2 → .3`
3. rename `.1 → .2`
4. rename current → `.1`
5. create a fresh new current file

### Hands-on: see rotated logs on your machine

List log files (will vary by distro):

```bash
ls -lh /var/log | head -n 50
```

Look for rotated patterns:

```bash
ls -lh /var/log | grep -E '\.([0-9]+)(\.gz)?$' | head -n 50
```

### View a rotated compressed log (if you have `.gz`)

Example patterns:

```bash
# View first lines
zcat /var/log/auth.log.2.gz | head

# Search inside a compressed log
zgrep -n "Failed password" /var/log/auth.log.*.gz
```

### Understand the “what if a process is writing while rotation happens?”

Linux file descriptors keep pointing to the same underlying file even if it gets renamed. So:

* If a program already has the file open and rotation renames it, the program may continue writing to the renamed file (e.g., `auth.log.1`).
* If the program opens the logfile after rotation, it will create/write to the new `auth.log`.

### Hands-on: safely simulate what `logrotate` *would* do (no changes)

Dry-run debug mode:

```bash
sudo logrotate -d /etc/logrotate.conf
```

Force a rotation run (this **does** changes) is possible, but only do it if you understand the impact:

```bash
sudo logrotate -f /etc/logrotate.conf
```

---

## Quick “cheat combinations” you’ll actually use

```bash
# Current boot, one unit
journalctl -b -u ssh

# Previous boot, kernel only, high severity
journalctl -b -1 -k -p 0..3

# Follow one unit live
journalctl -f -u NetworkManager

# Find unit names present in the journal
journalctl -F _SYSTEMD_UNIT | sort
```
