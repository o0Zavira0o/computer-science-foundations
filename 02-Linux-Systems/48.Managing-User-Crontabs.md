## Managing User Crontabs, System Cron, and Creating a systemd Timer + Service

---

## 1) User crontabs: what they are and how they’re installed

### 1.1 Concept

Each user can have a personal scheduled task list called a **crontab**.

$$
\text{User crontab} ; \xrightarrow{\text{managed by }} \texttt{crontab} \text{ command}
$$

On many systems, the installed per-user crontab files live under something like:

$$
/var/spool/cron \quad \text{or} \quad /var/spool/cron/crontabs
$$

Normal users usually **can’t** directly write there; the `crontab` command is the safe interface.

---

## 2) Hands-on: install a user crontab from a file 

> This demo schedules a task that appends a timestamped line to a file in your home directory.

### Exercise A — Create a new cron target script (fresh)

**Step 1: Create a script that appends a line**

```bash
mkdir -p "$HOME/bin"
cat > "$HOME/bin/cron_file_install_demo.sh" <<'EOF'
#!/usr/bin/env bash
echo "cron-file-install-demo: $(date -Is)" >> "$HOME/cron_file_install_demo.log"
EOF
chmod +x "$HOME/bin/cron_file_install_demo.sh"
```

**Step 2: Test it manually**

```bash
"$HOME/bin/cron_file_install_demo.sh"
tail -n 3 "$HOME/cron_file_install_demo.log"
```

You should see a new line appended.

---

### Exercise B — Create a crontab file and install it

**Step 1: Make a crontab file (runs every 2 minutes)**

```bash
cat > "$HOME/mycrontab.demo" <<EOF
*/2 * * * * $HOME/bin/cron_file_install_demo.sh
EOF
```

**Step 2: Install it**

```bash
crontab "$HOME/mycrontab.demo"
```

**Step 3: Verify installed entries**

```bash
crontab -l
```

You should see the `*/2 * * * * ...` line.

**Step 4: Wait ~2–4 minutes, then verify it ran**

```bash
tail -n 10 "$HOME/cron_file_install_demo.log"
```

---

### Exercise C — Edit your crontab interactively (`crontab -e`)

This edits and installs in one step.

**Step 1: Open editor**

```bash
crontab -e
```

**Step 2: Make a safe small change**
For example, change the schedule from `*/2` to `*/5` (every 5 minutes), save, and exit.

**Step 3: Confirm**

```bash
crontab -l
```

If you make a syntax mistake, `crontab` usually reports the line and lets you retry.

---

### Exercise D — Remove your user crontab

To remove *your entire* crontab:

```bash
crontab -r
```

Confirm it’s gone:

```bash
crontab -l
```

---

## 3) System crontab files: `/etc/crontab` and `/etc/cron.d`

### 3.1 Why system cron exists

System maintenance tasks often run as `root`, but distros prefer managing them centrally using:

* `/etc/crontab` (global file)
* `/etc/cron.d/*` (drop-in cron files)

### 3.2 The key difference in format

User crontab lines are:

$$
\text{min hour dom mon dow command}
$$

System crontab lines add an extra field:

$$
\text{min hour dom mon dow \color{#000}{user} command}
$$

Example shape:

```text
42 6 * * * root /usr/local/bin/cleansystem > /dev/null 2>&1
```

That `root` field tells cron which user runs the command.

---

## 4) Hands-on: inspect system cron locations (read-only, safe)

> These commands **do not** modify system files.

### Exercise E — View `/etc/crontab` (if present)

```bash
sudo sed -n '1,200p' /etc/crontab
```

### Exercise F — List `/etc/cron.d` jobs (if present)

```bash
ls -l /etc/cron.d 2>/dev/null || echo "No /etc/cron.d directory on this system"
```

If there are files, preview one:

```bash
sudo sed -n '1,120p' /etc/cron.d/* 2>/dev/null | head -n 120
```

### Exercise G — See daily/weekly/monthly cron script directories

Many distros use these directories, triggered by entries in `/etc/crontab` or scripts like `run-parts`:

```bash
ls -l /etc/cron.hourly /etc/cron.daily /etc/cron.weekly /etc/cron.monthly 2>/dev/null
```

---

## 5) systemd timer units: a modern alternative to cron

### 5.1 Concept: two units working together

A **timer** schedules an activation, but the **service** defines the work.

$$
\texttt{.timer} \Rightarrow \text{triggers} \Rightarrow \texttt{.service}
$$

* `example.timer`: “When should it run?”
* `example.service`: “What should run?”

### 5.2 Why two units?

A timer is a reusable mechanism. It doesn’t contain the command; it points to the service unit.

---

## 6) Hands-on: create a timer + oneshot service you can observe

> This creates a user-level systemd timer (no root required) so it’s safe on most systems.
> You’ll see logs via `journalctl --user` and status via `systemctl --user`.

### Exercise H — Create a user service that writes to the journal

**Step 1: Create the service unit**

```bash
mkdir -p "$HOME/.config/systemd/user"
cat > "$HOME/.config/systemd/user/timerdemo.service" <<'EOF'
[Unit]
Description=Timer Demo Service (oneshot)

[Service]
Type=oneshot
ExecStart=/usr/bin/systemd-cat -t timerdemo echo "timerdemo fired at $(date -Is)"
EOF
```

What this does:

* Runs once and exits (`Type=oneshot`)
* Sends a log line to the journal with tag `timerdemo`

---

### Exercise I — Create a user timer that triggers the service every minute

**Step 1: Create the timer unit**

```bash
cat > "$HOME/.config/systemd/user/timerdemo.timer" <<'EOF'
[Unit]
Description=Timer Demo (runs every minute)

[Timer]
OnCalendar=*-*-* *:*:00
Unit=timerdemo.service

[Install]
WantedBy=timers.target
EOF
```

Meaning of `OnCalendar`:

$$
\text{every day, every hour, every minute, at second } 00
$$

---

### Exercise J — Load units, start the timer, and enable it

**Step 1: Reload user systemd so it sees the new units**

```bash
systemctl --user daemon-reload
```

**Step 2: Start the timer now**

```bash
systemctl --user start timerdemo.timer
```

**Step 3: Enable it so it starts automatically (for your user)**

```bash
systemctl --user enable timerdemo.timer
```

---

### Exercise K — Verify the timer schedule and observe runs

**Step 1: List your active timers**

```bash
systemctl --user list-timers --all | grep timerdemo || true
```

**Step 2: Wait 1–2 minutes, then check journal entries**

```bash
journalctl --user -t timerdemo -n 20
```

You should see lines like:

$$
\texttt{timerdemo fired at 2026-...}
$$

**Step 3: Check service execution history**

```bash
systemctl --user status timerdemo.service --no-pager
```

You’ll often see last run time and exit status.

---

### Exercise L — Stop and remove the demo

**Stop and disable timer**

```bash
systemctl --user stop timerdemo.timer
systemctl --user disable timerdemo.timer
```

**Remove unit files**

```bash
rm -f "$HOME/.config/systemd/user/timerdemo.timer" "$HOME/.config/systemd/user/timerdemo.service"
systemctl --user daemon-reload
```

---

## 7) Understanding the “race condition” note (why logs may not show a unit)

### 7.1 The issue (simplified)

If a service runs extremely fast and logs via certain paths (e.g., syslog logger), journald may not reliably attach `_SYSTEMD_UNIT` metadata to the message because mapping can depend on timing/process info.

### 7.2 Why the demo above avoids that

Using:

$$
\texttt{systemd-cat}
$$

writes directly into journald in a way that’s easy to trace, so you reliably see the tag (`-t timerdemo`) in:

```bash
journalctl --user -t timerdemo
```

---

## 8) Quick mental map

* **User crontab**: managed with `crontab -l/-e/-r` and install via `crontab file`
* **System cron**: `/etc/crontab` and `/etc/cron.d/*` (includes a “run as user” field)
* **systemd timers**: `.timer` schedules, `.service` executes; `Type=oneshot` is ideal for periodic tasks


## cron vs systemd Timers vs `at` — Choosing the Right Scheduler + One-Time Jobs with `at` and `systemd-run` 

---

## 1) cron vs. systemd timer units: what’s the real difference?

### 1.1 Mental model

Think in terms of **what you want**:

$$
\text{Run repeatedly} \Rightarrow \text{cron or systemd timers}
$$
$$
\text{Run once later} \Rightarrow \text{at or systemd-run (transient timer)}
$$

---

## 2) When cron is better (practical reasons)

### 2.1 Simpler configuration

Cron is one line:

$$
\text{schedule} + \text{command}
$$

You don’t need to define separate units.

### 2.2 Compatibility

Many third-party tools and guides assume cron exists.

### 2.3 Easy user installation

Any user can schedule tasks with their own crontab without learning systemd concepts.

---

## 3) When systemd timers are better

### 3.1 Better process tracking (cgroups)

systemd groups processes in **cgroups**, so you get cleaner tracking:

$$
\text{task processes} \subset \text{unit cgroup}
$$

### 3.2 Better logging + diagnostics

Timers/services integrate naturally with:

$$
\texttt{journalctl} \quad \text{and unit status}
$$

You can see:

* when it last ran
* exit codes
* duration
* logs tied to the unit

### 3.3 More flexible scheduling

`OnCalendar=` supports rich calendar expressions and other triggers exist (`OnActiveSec=`, etc.).

### 3.4 Dependency + activation graph

You can specify ordering, dependencies, and environment in a standardized way.

---

## 4) Hands-on comparison: observe visibility differences 

> We’ll create **two one-time jobs** (not periodic):
>
> * one using `at`
> * one using `systemd-run`
>   You’ll observe how each is listed/managed.

---

# Part A — One-time scheduling with `at`

## 5) `at`: schedule a one-time job

### 5.1 Check if `atd` is installed and running

**Step 1: See if the command exists**

```bash
command -v at || echo "at is not installed"
```

**Step 2: Check the service (common names)**

```bash
systemctl status atd --no-pager 2>/dev/null || systemctl status atd.service --no-pager 2>/dev/null || echo "atd service not found"
```

If `at` is missing, installing it depends on distro (package often named `at`).

---

## 6) Hands-on: schedule a job 2 minutes from now (safe output file)

### Exercise 1 — Create a target file and schedule a write

**Step 1: Schedule a job**
This schedules a job for “now + 2 minutes” (more portable than specific clock times):

```bash
echo "echo at-demo ran at \$(date -Is) >> \$HOME/at_demo.log" | at now + 2 minutes
```

**Step 2: List queued jobs**

```bash
atq
```

You’ll see a job number like:

$$
\text{job_id}
$$

**Step 3: Wait ~2–3 minutes, then verify it ran**

```bash
tail -n 5 "$HOME/at_demo.log"
```

**Step 4: View the job definition (before it runs)**
If it hasn’t run yet and you want to inspect it:

```bash
jobid=$(atq | awk 'NR==1 {print $1}')
at -c "$jobid" | head -n 40
```

---

## 7) Remove a queued `at` job (if you want to cancel it)

### Exercise 2 — Cancel the next queued job

```bash
jobid=$(atq | awk 'NR==1 {print $1}')
$$ -n "$jobid" $$ && atrm "$jobid"
atq
```

---

# Part B — One-time scheduling with `systemd-run` (timer equivalent to `at`)

## 8) `systemd-run` as an “at replacement”

### 8.1 What it does

`systemd-run` can create a **transient** unit:

$$
\text{creates} ;; run\text{-}\langle id\rangle.\text{timer} \Rightarrow run\text{-}\langle id\rangle.\text{service}
$$

You can then manage and inspect it with normal systemd tools.

---

## 9) Hands-on: schedule a one-time systemd job 2 minutes in the future

> This does not create permanent unit files. It’s transient.

### Exercise 3 — Create a transient timer using an offset (`--on-active`)

**Step 1: Schedule a job to run once after 2 minutes**

```bash
systemd-run --on-active=2m /bin/sh -c 'echo systemd-run-demo ran at $(date -Is) >> "$HOME/systemd_run_demo.log"'
```

You should see output telling you the generated timer and service unit names.

**Step 2: List timers and find the created one**

```bash
systemctl list-timers --all | grep run- || true
```

**Step 3: Inspect details of the newest “run-” timer**
This grabs the most recently created `run-*.timer` from the systemd list:

```bash
timer=$(systemctl list-timers --all --no-legend | awk '$1 ~ /^run-.*\.timer$/ {print $1}' | tail -n 1)
echo "Timer unit: $timer"
systemctl status "$timer" --no-pager
```

**Step 4: Wait ~2–3 minutes, then verify the job ran**

```bash
tail -n 5 "$HOME/systemd_run_demo.log"
```

**Step 5: Inspect the service run result**
Find its paired service name:

```bash
service="${timer%.timer}.service"
echo "Service unit: $service"
systemctl status "$service" --no-pager
```

This is one big advantage over `at`: you get structured status, exit codes, and timestamps.

---

## 10) Important `--on-calendar` warning (avoid accidental daily repeats)

When you use `--on-calendar`, include a **full future date and time**, not just a time-of-day, or you may accidentally create:

$$
\text{runs every day at that time}
$$

### Exercise 4 — Correct use of `--on-calendar` (one-time)

Pick a time 3 minutes from now using `date` to generate it:

```bash
future=$(date -d 'now + 3 minutes' '+%Y-%m-%d %H:%M:%S')
echo "$future"
systemd-run --on-calendar="$future" /bin/sh -c 'echo calendar-demo ran at $(date -Is) >> "$HOME/systemd_run_calendar_demo.log"'
```

Verify timers:

```bash
systemctl list-timers --all | grep run- || true
```

---

# Part C — Timers as regular users + “linger”

## 11) User timers vs root/system timers

### 11.1 Why user timers may stop when you log out

User timers run under your **user systemd manager**:

$$
\text{user manager exists only while logged in (default)}
$$

So if you log out before the timer fires, it may not run.

### 11.2 Enable lingering (keep user manager running)

To keep your user manager alive after logout:

```bash
loginctl enable-linger "$(whoami)"
```

Check status:

```bash
loginctl show-user "$(whoami)" -p Linger
```

If it prints:
$$
Linger=yes
$$
then your user manager can run timers even when you’re logged out.

> To turn it off later:

```bash
loginctl disable-linger "$(whoami)"
```

---

# Part D — Choosing between cron, timers, and at (decision guide)

## 12) Quick decision matrix

### 12.1 Recurring tasks

* **Use cron** when:

  * you want minimal setup
  * you need broad compatibility
  * you don’t need deep process tracking

* **Use systemd timers** when:

  * you want strong observability (status + logs)
  * you want dependencies/order
  * you care about tracking child processes cleanly

### 12.2 One-time tasks

* **Use `at`** when:

  * you want the simplest “run once later” tool
  * you don’t care about systemd unit visibility

* **Use `systemd-run`** when:

  * you want one-time scheduling **plus** unit status and journal integration
  * you might later want to manage/cancel using systemctl tools

---

## 13) Key takeaways

$$
\textbf{cron: simple + compatible}
$$
$$
\textbf{systemd timers: observable + structured + dependency-aware}
$$
$$
\textbf{at: one-time and minimal}
$$
$$
\textbf{systemd-run: one-time + systemd-managed (transient) units}
$$

---
