# systemd: Unit Types, Dependency Graphs, and Configuration Management

Let's explore `systemd`, the modern system and service manager for Linux. Unlike older boot systems that simply started processes in a list, `systemd` manages a complex web of dependencies to ensure your system boots efficiently and reliably.

We will break down the building blocks of `systemd` (called Units), visualize how they depend on each other, and learn exactly where and how to configure them safely.

---

### **1. Building Blocks: Units and Unit Types**

In `systemd`, almost everything the system does is wrapped in an object called a **Unit**. When you start a unit (like a web server or a timer), you are **activating** it.

While there are many types of units, these four are the most critical for booting your system:

| Unit Type | Extension | Description | Example |
| :--- | :--- | :--- | :--- |
| **Service** | `.service` | Manages background processes (daemons). This is the most common type. | `ssh.service` (starts the secure shell server) |
| **Target** | `.target` | Groups other units together. Used for synchronization points during boot. | `multi-user.target` (reaches a state where users can log in) |
| **Socket** | `.socket` | Listens for network or IPC connections. Can wake up a service when a connection arrives. | `dbus.socket` |
| **Mount** | `.mount` | Controls filesystem mount points. | `home.mount` |

#### **Hands-on Example: Investigating Unit Types**
Let's see these units in action on your terminal.

**Step 1: List all active Service units**
This shows every background service currently running.
```bash
systemctl list-units --type=service
```

**Step 2: List all active Target units**
This shows the milestones your system has reached (like "Network is Online" or "System is Ready").
```bash
systemctl list-units --type=target
```

---

### **2. How Linux Boots: The Dependency Graph**

When you press the power button, `systemd` doesn't just read a list from top to bottom. Instead, it activates a single "Goal" unit (usually `default.target`) and calculates everything needed to achieve that goal.

*   **The Chain Reaction:** To reach `default.target`, the system might realize it first needs `multi-user.target`.
*   To reach `multi-user.target`, it needs `basic.target` and networking services.
*   To reach `basic.target`, it needs `sysinit.target` (early system initialization).

This structure forms a **Dependency Graph**, not just a simple tree, because different branches often merge back together.

#### **Visualizing the Graph (Conceptual)**
Imagine the flow like this:
1.  **default.target** (The Goal: Graphical Interface)
    *   *Requires:* **multi-user.target** (The Goal: Text Mode with Networking)
        *   *Requires:* **basic.target**
        *   *Requires:* **cron.service** (Task Scheduler)
        *   *Requires:* **dbus.service** (Message Bus)

#### **Hands-on Example: Seeing Dependencies**
You can ask `systemd` to show you exactly what a specific target needs.

**Check the dependencies of the graphical interface:**
```bash
systemctl list-dependencies graphical.target
```
*   *Output:* You will see a tree structure showing everything that must start for the GUI to work.

---

### **3. Configuration: Where Files Live**

`systemd` configuration files (Unit files) are scattered across the system. It is crucial to know which directory is for **System Defaults** (Do Not Touch) and which is for **User Customization** (Safe to Edit).

#### **The Golden Rule of Configuration**
*   **System Unit Directory (`/lib/systemd/system` or `/usr/lib/...`):**
    *   Contains default files installed by software packages.
    *   **WARNING:** Do not edit these. System updates will overwrite your changes.
*   **System Configuration Directory (`/etc/systemd/system`):**
    *   Contains your local custom configurations.
    *   Files here take **precedence** over the system directory.
    *   **ACTION:** Always make your changes here.

#### **Hands-on Example: finding your directories**
You can check exactly where your system looks for unit files.

**Check the search path priority:**
```bash
systemctl -p UnitPath show
```
*   *Note:* The paths listed first have higher priority. You will see `/etc/systemd/system` near the start (high priority) and `/lib/systemd/system` near the end (low priority).

**Find the exact location of unit directories:**
(Note: `pkg-config` might not be installed on minimal systems, but `ls` works everywhere).
```bash
ls -d /lib/systemd/system /usr/lib/systemd/system /etc/systemd/system 2>/dev/null
```

---

### **4. Anatomy of a Unit File**

Unit files look very similar to Windows `.ini` files. They are divided into sections using square brackets `[]`.

Let's dissect a typical service file (e.g., `sshd.service` or `dbus.service`).

#### **Structure Breakdown**

1.  **`[Unit]` Section:**
    *   **Description:** A human-readable name.
    *   **Requires / After:** Defines dependencies. "I need *Networking* to be ready before I start."
2.  **`[Service]` Section:**
    *   **ExecStart:** The actual command to run the software (e.g., `/usr/sbin/sshd`).
    *   **ExecReload:** The command to run if you ask the service to reload its config.
    *   **Type:** How the service starts (e.g., `simple`, `forking`, `notify`).
3.  **`[Install]` Section (Not shown in text example, but common):**
    *   **WantedBy:** Defines which Target this unit should attach to when enabled (e.g., `multi-user.target`).

#### **Hands-on Example: Reading a Unit File**
Let's look at the actual configuration for the SSH service (or `cron` if you don't have SSH).

```bash
# Display the content of the ssh service unit
cat /lib/systemd/system/ssh.service
# OR
cat /lib/systemd/system/sshd.service
```

*   **Look for `ExecStart`:** This is the precise command Linux runs to start the SSH server.
*   **Look for `After`:** This tells you what must happen *before* SSH starts (usually `network.target`).