## Understanding `/etc` and `/etc/passwd` — How Linux Stores System Config and User Accounts 

---

## 1) The structure and purpose of `/etc`

### 1.1 What `/etc` is for (in plain terms)

Think of:

$$
/etc = \text{machine-specific configuration}
$$

It contains **settings that customize this particular computer** (users, network config, services config overrides, etc.).

### 1.2 Why `/etc` is mostly directories now

Historically, many programs dumped one config file each directly into `/etc`, so it became crowded and hard to manage.

Modern Linux systems prefer:

$$
/etc/\text{program-name}/\text{...}
$$

Examples:

* systemd: `/etc/systemd/`
* ssh: `/etc/ssh/`
* apt: `/etc/apt/`

This makes it easier to find and maintain configs.

### 1.3 Preventing upgrades from overwriting your changes

A major design goal is:

$$
\text{Defaults live elsewhere (often in } /usr \text{), and local overrides live in } /etc
$$

So instead of editing one “main” file that might be replaced, many systems support **drop-in overrides** or **configuration snippets** in subdirectories under `/etc`.

---

## 2) Hands-on: explore `/etc` without repeating earlier exercises

### Exercise A — Prove that `/etc` is mostly directories now

**Step 1: Count how many entries are directories vs files**

```bash
cd /etc

echo "Directories:"; find . -maxdepth 1 -type d | wc -l
echo "Regular files:"; find . -maxdepth 1 -type f | wc -l
```

**Step 2: Show a “directory-heavy” listing**

```bash
ls -l | head -n 30
```

What you should notice:

* Many entries are directories (end with `/` visually in some listing styles)
* Fewer are single flat config files than older Unix systems

---

### Exercise B — Find configuration “snippets” or “drop-in” patterns

A common pattern is:

$$
/etc/\text{something.d}/
$$

Search for directories ending in `.d`:

```bash
cd /etc
find . -maxdepth 2 -type d -name "*.d" | sort | head -n 40
```

Then pick one and inspect it, for example:

```bash
ls -l /etc/ssh/ssh_config.d 2>/dev/null || echo "No ssh_config.d on this system"
```

This demonstrates how systems allow adding overrides **without editing one monolithic file**.

---

## 3) User management files: why `/etc/passwd` exists

### 3.1 Users at the kernel level: just numbers

Internally the kernel identifies users by:

$$
\text{UID} \in \mathbb{N}
$$

Usernames like `alice` are **user-space convenience labels** that must be mapped to UIDs.

### 3.2 Where the mapping lives

The classic local mapping database is:

```bash
/etc/passwd
```

It maps:

$$
\text{username} \rightarrow \text{UID (and other account info)}
$$

---

## 4) The `/etc/passwd` file format (7 fields, colon-separated)

Each line has **exactly 7 fields**, separated by colons:

$$
\text{f}_1 : \text{f}_2 : \text{f}_3 : \text{f}_4 : \text{f}_5 : \text{f}_6 : \text{f}_7
$$

### Field meanings

1. **Login name** (username)
2. **Password placeholder** (often `x` or `*`)
3. **UID** (user id)
4. **GID** (primary group id)
5. **GECOS** (real name / description)
6. **Home directory**
7. **Login shell**

Example structure:

$$
\texttt{juser:x:3119:1000:J. Random User:/home/juser:/bin/bash}
$$

---

## 5) Password field rules you must understand

### 5.1 Why it’s not a real password anymore

On most Linux systems, `/etc/passwd` does **not** store password hashes. Instead:

* `x` in field 2 usually means the password hash is stored in:

```bash
/etc/shadow
```

and that file is readable only by root.

### 5.2 What `*` means

If field 2 is `*`, it typically means:

$$
\text{login is disabled}
$$

### 5.3 Why a blank password field is dangerous

If the password field is empty (you see `::`), that implies:

$$
\text{no password required}
$$

This is unsafe on real systems and should generally never exist.

---

## 6) Hands-on: inspect `/etc/passwd` safely and decode it

> These exercises are new and show real function on your machine without editing anything.

### Exercise C — Display your own entry and interpret each field

**Step 1: Print your current username**

```bash
whoami
```

**Step 2: Show your `/etc/passwd` line**

$$
grep "^$(whoami):" /etc/passwd
$$

**Step 3: Split the line into labeled fields (easy to understand)**

```bash
line=$(grep "^$(whoami):" /etc/passwd)
IFS=: read -r user pass uid gid gecos home shell <<< "$line"

echo "Login name : $user"
echo "Pass field : $pass"
echo "UID        : $uid"
echo "GID        : $gid"
echo "GECOS      : $gecos"
echo "Home dir   : $home"
echo "Shell      : $shell"
```

What you should learn:

* You can *see* exactly what Linux stores for your account.
* UID/GID are numeric identity values used by the kernel.

---

### Exercise D — Prove that the kernel cares about UID, not the name

**Step 1: Show your UID/GID using standard tools**

```bash
id
```

**Step 2: Cross-check UID from `/etc/passwd`**

```bash
awk -F: -v u="$(whoami)" '$1==u {print "UID from /etc/passwd =", $3; print "GID from /etc/passwd =", $4}' /etc/passwd
```

**Step 3: Confirm your home and shell match what your session uses**

```bash
echo "$HOME"
echo "$SHELL"
```

Expected:

* `id` UID matches `/etc/passwd` field 3
* `$HOME` matches field 6
* `$SHELL` often matches field 7 (some sessions can override, but commonly it matches)

---

### Exercise E — Identify system users vs human users

A common convention:

* system/service accounts often have smaller UIDs (varies by distro)
* human users typically start at ( \ge 1000 ) on many distributions

List “likely human” accounts with UID ≥ 1000:

```bash
awk -F: '$3 >= 1000 {printf "%-20s UID=%-6s HOME=%s SHELL=%s\n", $1, $3, $6, $7}' /etc/passwd | head -n 30
```

List accounts with non-interactive shells (often service accounts):

```bash
awk -F: '($7 ~ /false|nologin/) {printf "%-20s UID=%-6s SHELL=%s\n", $1, $3, $7}' /etc/passwd | head -n 30
```

This helps you see how Linux differentiates:
$$
\text{interactive users} \quad \text{vs} \quad \text{service users}
$$

---

## 7) Key takeaways (mental model)

* `/etc` contains **machine-specific** configuration.
* Modern systems use subdirectories and `.d` snippets to avoid upgrade overwrites.
* `/etc/passwd` is a strict 7-field database mapping usernames to kernel identities (UIDs).
* Password hashes usually live in `/etc/shadow` (protected), not in `/etc/passwd`.
* A “user account” is largely a user-space convention built from `/etc/passwd` data (home directory may or may not exist).

---




## Special Users, `/etc/shadow`, Groups, and the `getty → login → shell` Flow 

---

## 1) Special users in Linux: what they are and why they exist

### 1.1 The one user the kernel truly treats specially

At the kernel level, users are identified by **UID numbers**:

$$
\text{UID} \in \mathbb{N}
$$

The **only UID with built-in special meaning** is:

$$
\textbf{UID } 0 \Rightarrow \text{superuser (root privileges)}
$$

So “root” is not magical because of the name — it’s magical because of UID (0).

---

### 1.2 Common “special” and “pseudo-users”

You’ll often see users like:

* `root` → UID 0
* `daemon`, `systemd-network`, etc. → service accounts (often non-login)
* `nobody` → very low-privilege account used to run some processes safely

**Pseudo-user idea:**
A pseudo-user typically **cannot log in**, but the system can still run processes under that UID for security isolation.

---

## 2) Hands-on: identify special users on *your* system (new exercises)

### Exercise A — Confirm root is UID 0 (and see what your account is)

```bash
id
id -u
```

Now check root explicitly:

```bash
id root
```

You should see root has:

$$
UID(root)=0 \quad \text{and usually} \quad GID(root)=0
$$

---

### Exercise B — Find “non-login” pseudo-users by their shell

Accounts that can’t log in often have shells like:

* `/usr/sbin/nologin`
* `/bin/false`

List them:

```bash
awk -F: '($7 ~ /(nologin|false)$/) {printf "%-25s UID=%-6s SHELL=%s\n", $1, $3, $7}' /etc/passwd | head -n 40
```

What you’re learning:

* Login permission is often enforced by the **shell field** (user-space convention).
* These accounts still exist so services can run under them.

---

### Exercise C — Inspect the `nobody` account (if present)

```bash
getent passwd nobody
```

If it exists, note:

* UID is often a very high number like (65534) (varies by distro)
* shell is often `nologin` or `false`

---

## 3) The `/etc/shadow` file: where authentication data actually lives

### 3.1 Why `/etc/shadow` exists

Historically, password hashes were stored in `/etc/passwd`, which is world-readable. That became unsafe.

So Linux uses:

```bash
/etc/passwd \Rightarrow \text{identity + account info}
```
```bash
/etc/shadow \Rightarrow \text{password hashes + expiration policy (root-only)}
```

### 3.2 Permissions matter (this is the “security boundary”)

Check permissions:

```bash
ls -l /etc/passwd /etc/shadow
```

Typical expectation:

* `/etc/passwd` is readable by everyone (many programs need it)
* `/etc/shadow` is readable only by root (or a special group), preventing ordinary users from reading password hashes

---

## 4) Hands-on: see the relationship between `/etc/passwd` and `/etc/shadow` (without exposing sensitive data)

### Exercise D — Confirm your passwd entry uses shadow (`x` in field 2)

```bash
getent passwd "$(whoami)"
```

In the output, the second field is often `x`, meaning:

$$
\text{password hash is stored in } /etc/shadow
$$

### Exercise E — Safely confirm your shadow entry exists (metadata only)

You generally can’t read `/etc/shadow` as a normal user. Instead, check if your account has a shadow record using root privileges **without printing the hash**:

```bash
sudo getent shadow "$(whoami)" | cut -d: -f1,3,4,5,6,7,8,9
```

Explanation of what this does:

* `sudo getent shadow user` retrieves the shadow line
* `cut ... -f1,3,4,5,6,7,8,9` **skips field 2**, where the password hash lives

So you can observe aging/expiration fields without revealing the hash.

---

## 5) Safe tools for manipulating users and passwords

### 5.1 User-facing commands

* Change your password:

```bash
passwd
```

* Change “real name” (GECOS):

```bash
chfn
```

* Change login shell (must be in `/etc/shells`):

```bash
chsh
```

### 5.2 Admin tools (don’t manually edit passwd)

Editing `/etc/passwd` directly is risky:

* syntax is strict (one mistake can break logins)
* concurrent edits can corrupt state

If you must edit safely:

* `vipw` edits `/etc/passwd` with locking + backup
* `vipw -s` edits `/etc/shadow`

---

## 6) Groups and `/etc/group`: sharing permissions

### 6.1 What groups do (practical view)

Groups mainly affect **file permissions**:

$
\text{owner permissions} \quad+\quad \text{group permissions} \quad+\quad \text{others permissions}
$

A group is identified by:

$
\text{GID} \in \mathbb{N}
$

### 6.2 `/etc/group` format (4 fields)

Each line is:

$
\text{groupname} : \text{password} : \text{GID} : \text{member list}
$

* member list is optional (comma-separated)
* users whose **primary GID** matches are also members, even if not listed

---

## 7) Hands-on: understand your groups (new exercises)

### Exercise F — See all groups you belong to (simple + reliable)

```bash
groups
```

### Exercise G — Show your primary group and numeric IDs

```bash
id
```

Focus on:

* `uid=...`
* `gid=...` (primary group)
* `groups=...` (supplementary groups)

### Exercise H — Map your primary GID back to a group name

```bash
gid=$(id -g)
getent group "$gid"
```

This proves:

$
\text{GID number} \leftrightarrow \text{group entry}
$

### Exercise I — Show which users are explicitly listed as members of a group

Pick a group you’re in (from `groups`), then run:

```bash
getent group <groupname>
```

You’ll see the 4th field as a member list (may be empty).

---

## 8) `getty` and `login`: how console logins work (the process chain)

### 8.1 The classic flow (virtual terminals)

On a text console (like `Ctrl+Alt+F2`):

$
\text{getty} \rightarrow \text{login} \rightarrow \text{your shell}
$

* **getty**: attaches to a terminal device (e.g. `/dev/tty1`) and prints the “login:” prompt
* **login**: asks for password and performs authentication (often via PAM)
* if success: `login` does an `exec()` into your shell (bash/zsh/etc.)

---

## 9) Hands-on: observe getty on your system (without switching terminals)

### Exercise J — List active getty services (systemd view)

```bash
systemctl list-units "getty@*.service" --no-pager
```

If you see something like `getty@tty1.service`, that means a getty is (or can be) managing that virtual terminal.

### Exercise K — Inspect one getty unit configuration

Pick a unit from the list (example: `getty@tty1.service`) and run:

```bash
systemctl cat getty@tty1.service
```

You’ll likely see `agetty` being used.

### Exercise L — Confirm agetty process arguments (process view)

```bash
ps -eo pid,tty,comm,args | grep -E 'agetty|getty' | grep -v grep
```

You may see output indicating which TTY it is attached to.

---

## 10) Key takeaways (quick mental model)

* **Root is special only because UID = 0**.
* **Pseudo-users** exist to run services with minimal privileges; login is often blocked via shell set to `nologin`/`false`.
* `/etc/passwd` is identity mapping; `/etc/shadow` is **protected authentication + aging**.
* Use `passwd/chfn/chsh` for user changes; use admin tools for account management; avoid manual edits.
* Groups exist mainly to control shared file access.
* Console login pipeline is:

$
\text{getty} \rightarrow \text{login} \rightarrow \text{shell}
$

---