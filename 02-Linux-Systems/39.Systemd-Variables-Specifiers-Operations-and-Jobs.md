# Deep Dive into Systemd: Variables, Specifiers, Operations, and Jobs

This guide provides an explanation of Systemd unit files function, how to interpret variables and specifiers, and how to control system services using the command line.

---

## **1. Variables in Unit Files**

Systemd unit files (configuration files ending in `.service`, `.socket`, etc.) often behave like scripts. They utilize variables to make configurations dynamic and flexible. You can identify a variable because it is prefixed with a dollar sign (`$`).

There are two primary sources for these variables:

1.  **Environment Files:**
    You can define specific values in an external text file (often located in `/etc/sysconfig/` or `/etc/default/`). By using the directive `EnvironmentFile=`, systemd reads that file and makes those variables available to the command lines starting the service.
    *   *Example:* `$OPTIONS` might hold flags like `-D` or verbose mode settings.

2.  **Internal Systemd Variables:**
    Systemd automatically tracks specific data points about a service.
    *   **$MAINPID:** This is the most critical internal variable. It holds the Process ID (PID) of the main service process. Systemd remembers this PID so it can send signals to the specific process later.
    *   *Usage:* It is frequently used in `ExecReload`. Instead of stopping and starting a service, systemd sends a `HUP` (Hang Up) signal to the `$MAINPID`. This tells the application to reload its configuration file on the fly without disconnecting active users.

### **Hands-on Example: Inspecting Variables**
We will look at the `sshd` (Secure Shell) service to see how it uses variables.

**Step 1:** View the configuration of the SSH service.
Open your terminal and type:
```bash
systemctl cat sshd.service
```
*Look for lines starting with `EnvironmentFile` and lines using `$OPTIONS` or `$MAINPID`.*

**Step 2:** Check the current Main PID of the SSH service.
```bash
systemctl show --property MainPID sshd.service
```
*This outputs the variable `$MAINPID` that systemd is currently tracking.*

---

## **2. Specifiers and Instances**

Specifiers are dynamic placeholders that systemd replaces with actual data when the unit is loaded. They differ from variables as they start with a percentage sign (`%`).

### **Common Specifiers**
*   **%n**: The full name of the unit (e.g., `sshd.service`).
*   **%h**: The hostname of the computer.

### **Template Units and Instances (@)**
Systemd allows you to create a single "Template" unit file and spawn multiple "Instances" of it. This is useful for running the same service on different interfaces or ports (e.g., login prompts on different terminals).

*   **The Syntax:** A unit filename ending in `@` before the suffix (e.g., `getty@.service`) is a template.
*   **The Instance:** The text placed between the `@` and the `.service` when starting the unit is the **Instance Name**.
*   **The Specifier (%I or %i):** Inside the unit file, `%I` represents the instance name.

**How it works:**
1.  You have a file named `getty@.service`.
2.  Systemd starts `getty@tty1.service`.
3.  Inside the file, systemd replaces `%I` with `tty1`.

### **Hands-on Example: Understanding Templates**
Let's look at the `getty` service, which handles terminal logins.

**Step 1:** List all running instances of the getty service.
```bash
systemctl list-units --all | grep "getty@"
```
*You will likely see `getty@tty1.service` or `getty@tty2.service`.*

**Step 2:** detailed look at how the specifier is used.
```bash
systemctl cat "getty@.service"
```
*Scan the output for `%I`. You will see it used in the `ExecStart` command to tell the program which TTY device to open.*

---

## **3. Systemd Operations (systemctl)**

The `systemctl` command is the primary tool for interacting with the systemd manager.

### **Listing Units**
To see what is running on your system, you list the units.
*   **Active Units:** `systemctl list-units` (default behavior).
*   **All Units:** `systemctl list-units --all` (shows inactive units too).
*   **Full Names:** `systemctl list-units --full` (prevents long names from being cut off with ellipses `...`).

### **Checking Unit Status**
The most useful command for troubleshooting is `status`. It provides a snapshot of the service.

The output contains:
1.  **Loaded:** Where the config file is and if it is enabled to start at boot.
2.  **Active:** The current state (running, failed, exited) and how long it has been running.
3.  **Main PID:** The ID of the primary process.
4.  **CGroup:** The Control Group hierarchy showing the main process and any child processes it spawned.
5.  **Logs:** The last few lines of log output (from the journal).

### **Control Groups (cgroups)**
Systemd organizes processes into control groups. If a service crashes or is stopped, systemd knows exactly which processes belong to it (even if the service spawned child processes) and cleans them all up.

### **Hands-on Example: Status and Cgroups**

**Step 1:** Check the status of the SSH service.
```bash
systemctl status sshd
```
*Observe the `CGroup` section. It shows the tree of processes.*

**Step 2:** View the entire system's cgroup hierarchy.
```bash
systemd-cgls
```
*This command gives a visual tree of every service and process systemd is managing.*

**Step 3:** View logs specifically for a unit.
If the status command didn't show enough log history, use the journal.
```bash
journalctl --unit=sshd
```
*(Press `q` to exit the log view).*

---

## **4. Jobs, States, and Reloading**

### **Managing State**
You change the state of a unit using standard commands:
*   `systemctl start unit_name`
*   `systemctl stop unit_name`
*   `systemctl restart unit_name`

### **Two Types of Reloads**
1.  **Service Reload (`systemctl reload unit`):**
    This sends a signal to the service (usually via `$MAINPID`) asking it to reread its own configuration file. The process does *not* stop running.
2.  **Daemon Reload (`systemctl daemon-reload`):**
    This tells systemd to reread *all* unit files on the disk. You must run this if you manually edit a `.service` file, or systemd will continue using the cached version.

### **Understanding "Jobs"**
In systemd, a "Job" is a request to change a state (e.g., "Start Service A").
*   Most of the time, jobs finish instantly.
*   If a service takes a long time to start (e.g., waiting for network hardware), it remains in the job queue.
*   Other services waiting on that delayed service will also sit in the job queue as "waiting."

### **Hands-on Example: Monitoring Jobs**

**Step 1:** List current jobs.
On a fully booted, stable system, this list should be empty.
```bash
systemctl list-jobs
```

**Step 2:** Simulate a job (Optional/Conceptual).
If you were to restart a heavy service like a graphical interface, and quickly ran `systemctl list-jobs` in another terminal, you would see the `start` job running and potentially other jobs waiting for it to finish.