# Deep Dive into Systemd: Variables, Specifiers, Operations, and Jobs

This guide provides an explanation of Systemd unit files function, how to interpret variables and specifiers, and how to control system services using the command line.

---

## **1. Variables in Unit Files**

Systemd unit files (configuration files ending in `.service`, `.socket`, etc.) often behave like scripts. They utilize variables to make configurations dynamic and flexible. You can identify a variable because it is prefixed with a dollar sign (`$`).

There are two primary sources for these variables:

1.  **Environment Files:**
    You can define specific values in an external text file (often located in `/etc/sysconfig/` or `/etc/default/`). By using the directive `EnvironmentFile=`, systemd reads that file and makes those variables available to the command lines starting the service.
    *   *Example:* `$OPTIONS` might hold flags like `-D` or verbose mode settings.

2.  **Internal Systemd Variables:**
    Systemd automatically tracks specific data points about a service.
    *   **$MAINPID:** This is the most critical internal variable. It holds the Process ID (PID) of the main service process. Systemd remembers this PID so it can send signals to the specific process later.
    *   *Usage:* It is frequently used in `ExecReload`. Instead of stopping and starting a service, systemd sends a `HUP` (Hang Up) signal to the `$MAINPID`. This tells the application to reload its configuration file on the fly without disconnecting active users.

### **Hands-on Example: Inspecting Variables**
We will look at the `sshd` (Secure Shell) service to see how it uses variables.

**Step 1:** View the configuration of the SSH service.
Open your terminal and type:
```bash
systemctl cat sshd.service
```
*Look for lines starting with `EnvironmentFile` and lines using `$OPTIONS` or `$MAINPID`.*

**Step 2:** Check the current Main PID of the SSH service.
```bash
systemctl show --property MainPID sshd.service
```
*This outputs the variable `$MAINPID` that systemd is currently tracking.*

---

## **2. Specifiers and Instances**

Specifiers are dynamic placeholders that systemd replaces with actual data when the unit is loaded. They differ from variables as they start with a percentage sign (`%`).

### **Common Specifiers**
*   **%n**: The full name of the unit (e.g., `sshd.service`).
*   **%h**: The hostname of the computer.

### **Template Units and Instances (@)**
Systemd allows you to create a single "Template" unit file and spawn multiple "Instances" of it. This is useful for running the same service on different interfaces or ports (e.g., login prompts on different terminals).

*   **The Syntax:** A unit filename ending in `@` before the suffix (e.g., `getty@.service`) is a template.
*   **The Instance:** The text placed between the `@` and the `.service` when starting the unit is the **Instance Name**.
*   **The Specifier (%I or %i):** Inside the unit file, `%I` represents the instance name.

**How it works:**
1.  You have a file named `getty@.service`.
2.  Systemd starts `getty@tty1.service`.
3.  Inside the file, systemd replaces `%I` with `tty1`.

### **Hands-on Example: Understanding Templates**
Let's look at the `getty` service, which handles terminal logins.

**Step 1:** List all running instances of the getty service.
```bash
systemctl list-units --all | grep "getty@"
```
*You will likely see `getty@tty1.service` or `getty@tty2.service`.*

**Step 2:** detailed look at how the specifier is used.
```bash
systemctl cat "getty@.service"
```
*Scan the output for `%I`. You will see it used in the `ExecStart` command to tell the program which TTY device to open.*

---

## **3. Systemd Operations (systemctl)**

The `systemctl` command is the primary tool for interacting with the systemd manager.

### **Listing Units**
To see what is running on your system, you list the units.
*   **Active Units:** `systemctl list-units` (default behavior).
*   **All Units:** `systemctl list-units --all` (shows inactive units too).
*   **Full Names:** `systemctl list-units --full` (prevents long names from being cut off with ellipses `...`).

### **Checking Unit Status**
The most useful command for troubleshooting is `status`. It provides a snapshot of the service.

The output contains:
1.  **Loaded:** Where the config file is and if it is enabled to start at boot.
2.  **Active:** The current state (running, failed, exited) and how long it has been running.
3.  **Main PID:** The ID of the primary process.
4.  **CGroup:** The Control Group hierarchy showing the main process and any child processes it spawned.
5.  **Logs:** The last few lines of log output (from the journal).

### **Control Groups (cgroups)**
Systemd organizes processes into control groups. If a service crashes or is stopped, systemd knows exactly which processes belong to it (even if the service spawned child processes) and cleans them all up.

### **Hands-on Example: Status and Cgroups**

**Step 1:** Check the status of the SSH service.
```bash
systemctl status sshd
```
*Observe the `CGroup` section. It shows the tree of processes.*

**Step 2:** View the entire system's cgroup hierarchy.
```bash
systemd-cgls
```
*This command gives a visual tree of every service and process systemd is managing.*

**Step 3:** View logs specifically for a unit.
If the status command didn't show enough log history, use the journal.
```bash
journalctl --unit=sshd
```
*(Press `q` to exit the log view).*

---

## **4. Jobs, States, and Reloading**

### **Managing State**
You change the state of a unit using standard commands:
*   `systemctl start unit_name`
*   `systemctl stop unit_name`
*   `systemctl restart unit_name`

### **Two Types of Reloads**
1.  **Service Reload (`systemctl reload unit`):**
    This sends a signal to the service (usually via `$MAINPID`) asking it to reread its own configuration file. The process does *not* stop running.
2.  **Daemon Reload (`systemctl daemon-reload`):**
    This tells systemd to reread *all* unit files on the disk. You must run this if you manually edit a `.service` file, or systemd will continue using the cached version.

### **Understanding "Jobs"**
In systemd, a "Job" is a request to change a state (e.g., "Start Service A").
*   Most of the time, jobs finish instantly.
*   If a service takes a long time to start (e.g., waiting for network hardware), it remains in the job queue.
*   Other services waiting on that delayed service will also sit in the job queue as "waiting."

### **Hands-on Example: Monitoring Jobs**

**Step 1:** List current jobs.
On a fully booted, stable system, this list should be empty.
```bash
systemctl list-jobs
```

**Step 2:** Simulate a job (Optional/Conceptual).
If you were to restart a heavy service like a graphical interface, and quickly ran `systemctl list-jobs` in another terminal, you would see the `start` job running and potentially other jobs waiting for it to finish.

# Adding, Removing, and Configuring Systemd Units

This guide details how to create custom systemd units, manage their dependencies, properly remove them, and configure how systemd tracks and synchronizes processes using various service types.

---

## **1. Adding Units to systemd**

Adding units involves creating a configuration file, placing it in the correct directory, and then activating it.

*   **Location:** Custom unit files should be placed in `/etc/systemd/system`.
*   **Reason:** This directory takes precedence over system defaults (located in `/usr/lib/systemd/system`), ensuring your changes persist after system updates.

To understand how units interact, we will create two "Target" units. A target is a unit that groups other units together; it is often used to create synchronization points during boot.

### **Hands-on Example: Creating Dependent Targets**

We will create `test1.target` and `test2.target`. We will configure `test2` to "Want" `test1`. This means when you start `test2`, systemd will automatically start `test1` as well.

**Note:** You need `root` or `sudo` privileges for these commands.

**Step 1: Create the first unit file.**
Create a file named `test1.target` in the system configuration directory.
```bash
sudo nano /etc/systemd/system/test1.target
```
Paste the following content into the file:
```ini
[Unit]
Description=test 1
```
*(Press `Ctrl+O`, `Enter` to save, and `Ctrl+X` to exit).*

**Step 2: Create the second unit file with a dependency.**
Create `test2.target`. Notice the `Wants=` line.
```bash
sudo nano /etc/systemd/system/test2.target
```
Paste the following content:
```ini
[Unit]
Description=test 2
Wants=test1.target
```
*(Press `Ctrl+O`, `Enter` to save, and `Ctrl+X` to exit).*

**Step 3: Activate the second unit.**
By starting `test2.target`, the `Wants` directive triggers `test1.target`.
```bash
sudo systemctl start test2.target
```

**Step 4: Verify the status.**
Check the status of both units to confirm they are active.
```bash
systemctl status test1.target test2.target
```
*Expected Output:* You should see `Active: active` for both units. The logs will show "Reached target test 1" and "Reached target test 2".

---

## **2. Enabling Units (The [Install] Section)**

The `[Install]` section in a unit file handles dependencies that are created when a unit is **enabled** (configured to start at boot), rather than just started manually.

If your unit file contains an `[Install]` section, you must run the enable command:
```bash
sudo systemctl enable unit_name
```
This creates symbolic links on the filesystem that systemd reads during boot to satisfy dependencies.

---

## **3. Removing Units from systemd**

To cleanly remove a custom unit from your system, you must follow a specific order of operations to ensure no lingering processes or broken symlinks remain.

**Step 1: Deactivate the unit.**
Stop the unit immediately.
```bash
sudo systemctl stop unit_name
```

**Step 2: Disable the unit.**
If the unit had an `[Install]` section and was enabled, this removes the symbolic links.
```bash
sudo systemctl disable unit_name
```
*Note: If the unit is "static" (has no `[Install]` section), disabling it has no effect, which is normal.*

**Step 3: Delete the file.**
You can now safely remove the file from `/etc/systemd/system`.
```bash
sudo rm /etc/systemd/system/unit_name
```

---

## **4. Process Tracking and Synchronization**

Systemd uses Linux Kernel **cgroups** (control groups) to track processes. This allows systemd to manage services even if they spawn multiple subprocesses or detach from the terminal.

However, systemd needs to know *how* a service behaves when it starts so it knows when to consider the service "ready." This is defined using the `Type=` directive in the `[Service]` section of a unit file.

### **Service Types Explained**

Here is a detailed breakdown of the available types you can use in a unit file:

#### **1. Type=simple**
*   **Behavior:** The service process does not fork (it runs in the foreground). Systemd considers the service "started" immediately after it executes the main process.
*   **Use Case:** Standard applications that don't need to notify other services of their specific initialization state.
*   **limitation:** Because systemd assumes it is ready immediately, dependent services start right away. If the service takes a long time to initialize, dependent services might fail.

#### **2. Type=forking**
*   **Behavior:** The service launches, forks a child process (the background daemon), and the original parent process terminates.
*   **Systemd Action:** Systemd waits for the parent process to exit before considering the service "active."
*   **Use Case:** Traditional Unix daemons that "daemonize" themselves.

#### **3. Type=notify**
*   **Behavior:** Similar to `simple`, but the service is programmed to send a specific signal message (using `sd_notify()`) to systemd when it is finished initializing.
*   **Use Case:** Complex services where you need to be 100% sure the service is ready before starting anything that depends on it.

#### **4. Type=dbus**
*   **Behavior:** The service acquires a name on the D-Bus (Desktop Bus).
*   **Systemd Action:** Systemd considers the service ready only after it successfully registers its name on the bus.

#### **5. Type=oneshot**
*   **Behavior:** The process runs and then exits completely. Unlike `simple`, systemd waits for the process to finish before continuing to other units.
*   **Configuration:** Usually paired with `RemainAfterExit=yes`. This tells systemd: "Even though the process finished, consider this service 'Active'."
*   **Use Case:** Scripts that run a configuration task (like setting firewall rules) and then stop.

#### **6. Type=idle**
*   **Behavior:** Works exactly like `Type=simple`, but systemd delays the execution of the service until all other active jobs (requests) are processed.
*   **Use Case:** Services that output text to the console. This prevents the output from getting mixed up with status messages from other services starting at the same time.

### **Hands-on Example: Viewing Service Type**

To see where this is configured in a real service, we can look at the system's cron service or SSH service.

**Command:**
```bash
systemctl cat sshd.service
```
*Output:* Look for `[Service]`. You will likely see `Type=notify` (on modern systems) or `Type=forking`. This tells systemd exactly how to watch the SSH daemon to ensure it is running correctly.