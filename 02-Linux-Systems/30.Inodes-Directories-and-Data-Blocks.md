# Deep Dive into Linux Filesystem Architecture: Inodes, Directories, and Data Blocks

## Introduction
When you look at a file browser, you see folders inside folders containing files with names. However, this is just a user-friendly illusion created for humans.

Under the hood, a traditional Unix/Linux filesystem (like ext4) does not see "folders" or "filenames" in the way you do. Instead, it consists of two distinct parts:
1.  **The Data Pool:** A massive area of blocks where the actual contents of files (text, images, code) are stored.
2.  **The Database (Inode Table):** An index system that tracks information *about* the files, but not necessarily their names.

This guide explains how these components work together to organize your data.

---

## Part 1: The Core Concepts

### 1. The Inode (Index Node)
An **Inode** is a data structure (a card in the database) that describes a specific file. It contains metadata, such as:
*   File Type (Is it a file? A directory? A shortcut?)
*   Permissions (Who can read/write it?)
*   Size
*   **Location:** Which blocks in the Data Pool hold the actual content.

**Crucially:** An inode does **not** contain the filename. Inodes are identified strictly by a unique number (e.g., Inode #13).

### 2. The Directory
If inodes don't have names, how does the computer know that Inode #13 is `report.pdf`?
This is the job of a **Directory**.

To the filesystem, a Directory is just a special file. Its "data" is simply a list (a map) linking names to numbers.

$$ \text{Directory Entry} = \{ \text{Filename} \rightarrow \text{Inode Number} \} $$

### 3. The Root Inode
Every filesystem needs a starting point. In Linux (ext systems), the **Root Directory (`/`)** is always stored in **Inode #2**.

---

## Part 2: Hands-on Lab – Visualizing Inodes

To understand this, we will build a small file structure and use terminal commands to see the hidden numbers (Inodes) behind the files.

**Open your Linux terminal and type the following commands step-by-step.**

### Step 1: Create a Sandbox Environment
We will create a specific structure of folders and files.

```bash
# Create two directories
mkdir dir_1
mkdir dir_2

# Create content in dir_1
echo "Content A" > dir_1/file_1
echo "Content B" > dir_1/file_2
echo "Content C" > dir_1/file_3

# Create content in dir_2
echo "Content D" > dir_2/file_4
```

### Step 2: Create a Hard Link
A "Hard Link" is when two different filenames point to the exact same Inode number.

```bash
# Link file_5 in dir_2 to the same data as file_3
ln dir_1/file_3 dir_2/file_5
```

### Step 3: Reveal the Inodes
Now, we look at the structure *not* as a user, but as the filesystem sees it. We use the `-i` flag (show inode) and `-R` (recursive).

```bash
ls -i -R
```

**Analyze your output:**
You will see a number next to every file.
1.  Look at `dir_1/file_3`. Note the number (e.g., 12345).
2.  Look at `dir_2/file_5`. Note the number.
3.  **They are identical.** This proves they are the *same* file in the database, just with two different names (labels) in different directories.

---

## Part 3: The Internal Structure (Step-by-Step Analysis)

Let's break down exactly what the filesystem looks like based on the lab you just performed.

### 1. The Inode Table
Imagine the Inode Table looks like this (your specific numbers will differ, but the logic is the same):

| Inode \# | Type | Link Count | Data Location |
| :--- | :--- | :--- | :--- |
| **2** | Directory | 4 | [Block A] |
| **12** | Directory | 2 | [Block B] |
| **13** | File | 1 | [Block C] |
| **15** | File | **2** | [Block D] |

*   **Inode 2:** The Root of our filesystem.
*   **Inode 12:** Represents `dir_1`.
*   **Inode 15:** Represents the file containing "Content C". Notice the **Link Count is 2**. This means two filenames point to this one inode (`file_3` and `file_5`).

### 2. The Data Pool (The Contents)
Here is what is physically stored in the disk blocks:

**Block A (Data for Root Inode 2):**
This block contains the list of files in the root:
*   `dir_1` $\rightarrow$ Points to Inode **12**
*   `dir_2` $\rightarrow$ Points to Inode **76** (random example)

**Block B (Data for `dir_1` Inode 12):**
This block contains the list of files in `dir_1`:
*   `.` (Current) $\rightarrow$ Points to Inode **12**
*   `..` (Parent) $\rightarrow$ Points to Inode **2**
*   `file_1` $\rightarrow$ Points to Inode **13**
*   `file_3` $\rightarrow$ Points to Inode **15**

**Block D (Data for Inode 15):**
This block contains the actual text:
*   `"Content C"`

---

## Part 4: How the Kernel Finds a File (Path Resolution)

This is the most critical part of understanding filesystems. When you ask the computer to open `dir_1/file_2`, the Linux Kernel performs a "Treasure Hunt."

**The Goal:** Read `dir_1/file_2`

1.  **Start at Root:**
    The kernel knows the Root is always **Inode 2**. It goes to the Inode Table, finds #2, and sees it is a Directory.
2.  **Read Root Data:**
    It looks inside the data block for Inode 2. It searches for the string `"dir_1"`.
    *Found it!* `"dir_1"` maps to **Inode 12**.
3.  **Jump to Directory 1:**
    The kernel goes back to the Inode Table. It looks up **Inode 12**. It verifies it is a directory.
4.  **Read Directory 1 Data:**
    It looks inside the data block for Inode 12. It searches for the string `"file_2"`.
    *Found it!* `"file_2"` maps to **Inode 14**.
5.  **Jump to File:**
    The kernel goes to the Inode Table. It looks up **Inode 14**. It sees this is a regular file.
6.  **Read File Data:**
    It follows the link in Inode 14 to the actual Data Pool block containing `"Content B"`.

### The Special Dot Entries
You may have noticed every directory contains `.` and `..`.
*   **`.` (Dot):** Points to the Inode of the directory itself. (Self-reference).
*   **`..` (Dot-Dot):** Points to the Inode of the directory above it (Parent).
    *   *Example:* Inside `dir_1` (Inode 12), the entry `..` points to Inode 2 (Root). This allows the system to traverse backwards up the tree.

## Summary
*   **Files** are defined by **Inodes** (Metadata).
*   **Content** is stored in **Data Blocks**.
*   **Directories** are special files that act as **Phonebooks**, mapping Names $\rightarrow$ Inode Numbers.
*   **Hard Links** are simply multiple Phonebook entries pointing to the same Inode Number.

# Deep Dive into Filesystem Internals: Inodes, Link Counts, and Bitmaps

## Introduction
In the previous section, we learned that a filesystem is a database consisting of **Inodes** (ID cards) and **Data Blocks** (storage content). Now, we will explore the mechanisms that keep this database consistent. We will look at how the system counts connections to files (Link Counts), how it tracks free space (Bitmaps), and how the Operating System hides this complexity from the user.

---

## Part 1: Inodes and Link Counts

### 1.1 Viewing Inodes
Every file on your system is identified by a unique number called an **Inode Number**. You can view these numbers using the `-i` flag with the list command.

### 1.2 What is a "Link Count"?
When you run `ls -l`, you see a number in the second column (e.g., `1`, `2`, `4`). This is the **Link Count**.
The Link Count represents the total number of directory entries pointing to a specific Inode.

*   **Standard File:** Usually has a count of $1$. (One name points to one inode).
*   **Hard Link:** If you use the `ln` command (without `-s`), you create a second name pointing to the *same* inode. The count becomes $2$.

### 1.3 The Concept of "Unlinking" (Deletion)
When you type `rm filename`, you are not immediately destroying data. You are performing an **Unlink** operation.
1.  The kernel finds the inode.
2.  It removes the name from the directory.
3.  It subtracts $1$ from the Link Count ($Count = Count - 1$).
4.  **If (and only if) the count reaches 0**, the kernel deletes the data and frees the inode.

If a file has a Link Count of $2$, and you `rm` one name, the data remains safe because the count only drops to $1$.

---

## Part 2: Hands-on Lab – Hard Links and Deletion

In this lab, we will create a file, link it, and observe how "deleting" it doesn't actually delete it until the link count hits zero.

**Step 1: Setup the Playground**
```bash
# Create a folder to mess around in
mkdir inode_lab
cd inode_lab
```

**Step 2: Create a File and Check the Count**
```bash
# Create a file with some text
echo "Important Data" > original_file.txt

# List with Inode (-i) and details (-l)
ls -il original_file.txt
```
**Observation:**
*   Look at the first column (The Inode Number, e.g., `12345`).
*   Look at the third column (The Link Count). It should be **1**.

**Step 3: Create a Hard Link**
We will give this inode a second name.
```bash
# Create a hard link named 'backup_link.txt'
ln original_file.txt backup_link.txt

# Check both files
ls -il
```
**Observation:**
*   Both files have the **exact same Inode Number**.
*   The Link Count for *both* is now **2**.
*   They are not copies; they are two doors leading to the exact same room.

**Step 4: "Delete" the Original**
```bash
# Remove the original file
rm original_file.txt

# Check the remaining file
ls -il backup_link.txt
```
**Observation:**
*   The `original_file.txt` is gone.
*   However, `backup_link.txt` is still there.
*   **Crucially:** The content `"Important Data"` is not lost.
*   The Link Count has dropped from **2** to **1**.

---

## Part 3: Directory Link Counts

Directories calculate links differently than files. A standard, empty directory usually has a Link Count of **2**. Why?
1.  **The Parent Entry:** The directory's name inside its parent folder.
2.  **The Self Entry:** The `.` (dot) inside the directory itself.

If you create a subdirectory inside it, the count increases to **3**, because the subdirectory has a `..` (dot-dot) entry pointing back to the parent.

**Exception:** The Root directory (`/`) often has a count of 4 (or more) because the filesystem "Superblock" also points to it.

---

## Part 4: Hands-on Lab – Directory Math

Let's verify the math of directory links.

**Step 1: Create a Directory**
```bash
mkdir folder_A
```

**Step 2: Check the Count**
```bash
# -d tells ls to look AT the directory, not INSIDE it
ls -ld folder_A
```
**Observation:** The Link Count (3rd column) is **2**.
*(1 link from current folder + 1 link from `.` inside `folder_A`)*.

**Step 3: Create a Subdirectory**
```bash
mkdir folder_A/sub_B
ls -ld folder_A
```
**Observation:** The Link Count of `folder_A` rose to **3**.
*Reason:* `sub_B` contains a hidden file `..` which points back to `folder_A`.

---

## Part 5: Block Allocation (The Bitmap)

We know *files* are stored in blocks, but how does the computer know which blocks are empty and which are full?

### 5.1 The Block Bitmap
Imagine a seating chart in a movie theater. The filesystem uses a **Block Bitmap**: a sequence of bits (0s and 1s).
*   **0:** Block is Free.
*   **1:** Block is Used.

When you save a file:
1.  The system finds a `0` in the bitmap.
2.  It writes your data to that block.
3.  It flips the bit to `1`.

### 5.2 The Role of `fsck`
If you pull the power plug while the computer is writing, the Inode Table might say "I have a file!" but the Bitmap might say "That block is free!" (or vice versa).

The tool `fsck` (File System Consistency Check) fixes this:
1.  It walks through every Inode and calculates what the map *should* look like.
2.  It compares this to the actual Bitmap.
3.  If it finds files that exist but aren't listed in any directory (orphans), it moves them to the `lost+found` directory.

---

## Part 6: User Space and VFS

### 6.1 The Illusion of Simplicity
As a user, you type `stat filename` and see inode numbers. This is technically "leakage" of internal details into the user's world.
However, you typically don't need to worry about this. The Linux Kernel uses a layer called **VFS (Virtual File System)**.

### 6.2 VFS Abstraction
VFS acts as a translator.
*   The User says: "Open `photo.jpg`".
*   VFS translates this into Inode math.
*   VFS talks to the specific driver (ext4, XFS, etc.).

### 6.3 Compatibility Issues
Because VFS standardizes everything, sometimes it offers features that the underlying disk doesn't actually have.
*   **Example:** If you insert a USB drive formatted with **VFAT** (Windows format), and try to create a hard link (`ln`), it will fail.
*   **Reason:** VFAT does not have Inodes or Link Counts in its internal design. VFS tries to translate the command, but the VFAT driver says, "I can't do that."

### Summary
1.  **Inodes** define files. **Filenames** are just labels pointing to Inodes.
2.  **Unlinking** reduces the count. Data dies only when count is 0.
3.  **Bitmaps** track used space via simple 1s and 0s.
4.  **VFS** allows Linux to talk to many different filesystems, even if they don't support native Linux features like links.