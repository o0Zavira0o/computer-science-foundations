# Mastering Systemd Dependencies, Ordering, and Conditions

Systemd provides a robust framework for managing how services interact with one another. Unlike older systems that strictly ran one thing after another, systemd attempts to run things in parallel to boot faster. To do this safely, it uses **Dependencies** (relationship between units) and **Ordering** (timeline of events).

This guide explains how to define these relationships to ensure your system is both fast and fault-tolerant.

---

## **1. Dependency Types**

Dependencies define how units relate to one another logically. Systemd offers several keywords to define the strictness of these relationships.

### **The Keywords**

1.  **Requires (Strict):**
    *   If Unit A *Requires* Unit B, activating A will attempt to start B.
    *   **Critical:** If Unit B fails to start, Unit A is immediately deactivated.
    *   *Use case:* A web server that absolutely cannot function without the network.

2.  **Wants (Flexible - Recommended):**
    *   If Unit A *Wants* Unit B, activating A will attempt to start B.
    *   **Resilient:** If Unit B fails, Unit A ignores the failure and keeps running.
    *   *Use case:* A database server "wants" a logging plugin. If the logger fails, the database should still run.

3.  **Requisite (Prerequisite):**
    *   If Unit A has a *Requisite* on Unit B, systemd checks if B is **already** active.
    *   If B is not running, systemd will not even try to start B; it will simply fail Unit A immediately.

4.  **Conflicts (Negative):**
    *   If Unit A *Conflicts* with Unit B, starting A will automatically stop B. They cannot run simultaneously.

### **Hands-on Example: checking Dependencies**

You can inspect the dependencies of any running service using the `show` command.

**Step 1:** Check what the SSH service "Wants".
We use the `-p` flag to specify the property we want to see.
```bash
systemctl show -p Wants sshd.service
```
*Output:* You will likely see `Wants=network.target` or similar.

**Step 2:** Check what "Requires" the SSH service.
This checks the reverseâ€”what strictly needs SSH to function?
```bash
systemctl show -p RequiredBy sshd.service
```

---

## **2. Ordering (Before and After)**

It is important to understand that **Dependencies do not imply Order**.
If Unit A *Requires* Unit B, systemd will start them **at the same time** (in parallel) to speed up booting.

If Unit A actually needs Unit B to be fully finished before A starts, you must explicitly set the order.

*   **After:** If Unit A has `After=Unit B`, systemd waits for B to be "active" before starting A.
*   **Before:** The reverse of the above.

### **Hands-on Example: Controlling Order**

We will create two test services to demonstrate ordering.

**Step 1:** Create the first service (`first.service`).
```bash
sudo nano /etc/systemd/system/first.service
```
Content (This service just sleeps for 5 seconds to simulate a slow startup):
```ini
[Unit]
Description=First Service

[Service]
Type=oneshot
ExecStart=/bin/sleep 5
```

**Step 2:** Create the second service (`second.service`).
We make this unit start **After** `first.service`.
```bash
sudo nano /etc/systemd/system/second.service
```
Content:
```ini
[Unit]
Description=Second Service
After=first.service

[Service]
Type=oneshot
ExecStart=/bin/echo "Second Service Started"
```

**Step 3:** Start them together.
We will try to start the second service. Because of the ordering rule, systemd will check `first.service`. Note that we haven't defined a dependency (Wants/Requires), only an order. If we start both, the order is respected.
```bash
sudo systemctl start first.service second.service
```
*Observation:* The command will hang for 5 seconds (while `first` sleeps) before finishing `second`. If there were no ordering, `second` would have finished instantly while `first` was still sleeping.

---

## **3. Default and Implicit Dependencies**

To keep configuration files short, systemd adds "invisible" dependencies behind the scenes.

*   **Automatic Ordering:** If a target unit has `Wants=b.service`, systemd often implicitly adds `After=b.service` to ensure logical flow.
*   **Disabling Defaults:** If you are writing a very low-level unit (like a filesystem mount required for the boot process itself), you might need to prevent these automatic additions. You can add `DefaultDependencies=no` to the `[Unit]` section of your file.

### **Hands-on Example: revealing Implicit Dependencies**

Let's look at a Target unit. Targets usually have many implicit dependencies.

**Step 1:** check the "After" property of the `multi-user.target`.
```bash
systemctl show -p After multi-user.target
```
*Output:* You will see a long list of services (like `network.target`, `systemd-user-sessions.service`, etc.). Most of these are not written inside the `multi-user.target` file; they were added automatically or by other units "wanting" to be before it.

---

## **4. Conditional Dependencies**

Sometimes you don't want to depend on another *service*, but on the state of the *Operating System* (e.g., "Only run this if a specific configuration file exists").

Systemd checks these conditions **before** starting the unit. If the condition is false, the unit is skipped (it does not fail, it just does nothing).

**Common Conditions:**
*   `ConditionPathExists=`: Run only if this path exists.
*   `ConditionPathIsDirectory=`: Run only if the path is a directory.
*   `ConditionFileNotEmpty=`: Run only if the file exists and has size > 0.

*Note:* If a unit is skipped due to a condition, any other units that depend on it will still try to start (unless they strictly `Require` it).

### **Hands-on Example: Using Conditions**

We will create a service that only runs if a specific "flag" file exists.

**Step 1:** Create the conditional service.
```bash
sudo nano /etc/systemd/system/conditional.service
```
Content:
```ini
[Unit]
Description=Runs only if file exists
ConditionPathExists=/tmp/run_me

[Service]
Type=oneshot
ExecStart=/bin/echo "File found! Running service."
```

**Step 2:** Attempt to start it (without the file).
```bash
sudo systemctl start conditional.service
sudo systemctl status conditional.service
```
*Output:* You will see `ConditionPathExists=/tmp/run_me was not met`. The service did not run.

**Step 3:** Create the file and start again.
```bash
touch /tmp/run_me
sudo systemctl start conditional.service
sudo systemctl status conditional.service
```
*Output:* Now the logs will show "File found! Running service."

---

## **5. Other Dependency Types**

There are minor variations of the standard dependencies for specific edge cases:

*   **RequiresOverridable:**
    *   **Automatic behavior:** If the system is booting automatically, this acts like `Requires` (strict).
    *   **Manual behavior:** If a user manually starts the unit, this acts like `Wants` (flexible). This allows a user to force a service to start even if a dependency is failing, which is useful for debugging.