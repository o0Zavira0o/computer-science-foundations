# Mastering Systemd Dependencies, Ordering, and Conditions

Systemd provides a robust framework for managing how services interact with one another. Unlike older systems that strictly ran one thing after another, systemd attempts to run things in parallel to boot faster. To do this safely, it uses **Dependencies** (relationship between units) and **Ordering** (timeline of events).

This guide explains how to define these relationships to ensure your system is both fast and fault-tolerant.

---

## **1. Dependency Types**

Dependencies define how units relate to one another logically. Systemd offers several keywords to define the strictness of these relationships.

### **The Keywords**

1.  **Requires (Strict):**
    *   If Unit A *Requires* Unit B, activating A will attempt to start B.
    *   **Critical:** If Unit B fails to start, Unit A is immediately deactivated.
    *   *Use case:* A web server that absolutely cannot function without the network.

2.  **Wants (Flexible - Recommended):**
    *   If Unit A *Wants* Unit B, activating A will attempt to start B.
    *   **Resilient:** If Unit B fails, Unit A ignores the failure and keeps running.
    *   *Use case:* A database server "wants" a logging plugin. If the logger fails, the database should still run.

3.  **Requisite (Prerequisite):**
    *   If Unit A has a *Requisite* on Unit B, systemd checks if B is **already** active.
    *   If B is not running, systemd will not even try to start B; it will simply fail Unit A immediately.

4.  **Conflicts (Negative):**
    *   If Unit A *Conflicts* with Unit B, starting A will automatically stop B. They cannot run simultaneously.

### **Hands-on Example: checking Dependencies**

You can inspect the dependencies of any running service using the `show` command.

**Step 1:** Check what the SSH service "Wants".
We use the `-p` flag to specify the property we want to see.
```bash
systemctl show -p Wants sshd.service
```
*Output:* You will likely see `Wants=network.target` or similar.

**Step 2:** Check what "Requires" the SSH service.
This checks the reverse—what strictly needs SSH to function?
```bash
systemctl show -p RequiredBy sshd.service
```

---

## **2. Ordering (Before and After)**

It is important to understand that **Dependencies do not imply Order**.
If Unit A *Requires* Unit B, systemd will start them **at the same time** (in parallel) to speed up booting.

If Unit A actually needs Unit B to be fully finished before A starts, you must explicitly set the order.

*   **After:** If Unit A has `After=Unit B`, systemd waits for B to be "active" before starting A.
*   **Before:** The reverse of the above.

### **Hands-on Example: Controlling Order**

We will create two test services to demonstrate ordering.

**Step 1:** Create the first service (`first.service`).
```bash
sudo nano /etc/systemd/system/first.service
```
Content (This service just sleeps for 5 seconds to simulate a slow startup):
```ini
[Unit]
Description=First Service

[Service]
Type=oneshot
ExecStart=/bin/sleep 5
```

**Step 2:** Create the second service (`second.service`).
We make this unit start **After** `first.service`.
```bash
sudo nano /etc/systemd/system/second.service
```
Content:
```ini
[Unit]
Description=Second Service
After=first.service

[Service]
Type=oneshot
ExecStart=/bin/echo "Second Service Started"
```

**Step 3:** Start them together.
We will try to start the second service. Because of the ordering rule, systemd will check `first.service`. Note that we haven't defined a dependency (Wants/Requires), only an order. If we start both, the order is respected.
```bash
sudo systemctl start first.service second.service
```
*Observation:* The command will hang for 5 seconds (while `first` sleeps) before finishing `second`. If there were no ordering, `second` would have finished instantly while `first` was still sleeping.

---

## **3. Default and Implicit Dependencies**

To keep configuration files short, systemd adds "invisible" dependencies behind the scenes.

*   **Automatic Ordering:** If a target unit has `Wants=b.service`, systemd often implicitly adds `After=b.service` to ensure logical flow.
*   **Disabling Defaults:** If you are writing a very low-level unit (like a filesystem mount required for the boot process itself), you might need to prevent these automatic additions. You can add `DefaultDependencies=no` to the `[Unit]` section of your file.

### **Hands-on Example: revealing Implicit Dependencies**

Let's look at a Target unit. Targets usually have many implicit dependencies.

**Step 1:** check the "After" property of the `multi-user.target`.
```bash
systemctl show -p After multi-user.target
```
*Output:* You will see a long list of services (like `network.target`, `systemd-user-sessions.service`, etc.). Most of these are not written inside the `multi-user.target` file; they were added automatically or by other units "wanting" to be before it.

---

## **4. Conditional Dependencies**

Sometimes you don't want to depend on another *service*, but on the state of the *Operating System* (e.g., "Only run this if a specific configuration file exists").

Systemd checks these conditions **before** starting the unit. If the condition is false, the unit is skipped (it does not fail, it just does nothing).

**Common Conditions:**
*   `ConditionPathExists=`: Run only if this path exists.
*   `ConditionPathIsDirectory=`: Run only if the path is a directory.
*   `ConditionFileNotEmpty=`: Run only if the file exists and has size > 0.

*Note:* If a unit is skipped due to a condition, any other units that depend on it will still try to start (unless they strictly `Require` it).

### **Hands-on Example: Using Conditions**

We will create a service that only runs if a specific "flag" file exists.

**Step 1:** Create the conditional service.
```bash
sudo nano /etc/systemd/system/conditional.service
```
Content:
```ini
[Unit]
Description=Runs only if file exists
ConditionPathExists=/tmp/run_me

[Service]
Type=oneshot
ExecStart=/bin/echo "File found! Running service."
```

**Step 2:** Attempt to start it (without the file).
```bash
sudo systemctl start conditional.service
sudo systemctl status conditional.service
```
*Output:* You will see `ConditionPathExists=/tmp/run_me was not met`. The service did not run.

**Step 3:** Create the file and start again.
```bash
touch /tmp/run_me
sudo systemctl start conditional.service
sudo systemctl status conditional.service
```
*Output:* Now the logs will show "File found! Running service."

---

## **5. Other Dependency Types**

There are minor variations of the standard dependencies for specific edge cases:

*   **RequiresOverridable:**
    *   **Automatic behavior:** If the system is booting automatically, this acts like `Requires` (strict).
    *   **Manual behavior:** If a user manually starts the unit, this acts like `Wants` (flexible). This allows a user to force a service to start even if a dependency is failing, which is useful for debugging.

    # Managing Systemd Installation, Enabling Units, and On-Demand Startup

This guide covers the advanced mechanisms of how Systemd manages unit lifecycle through the `[Install]` section and how to configure efficient, on-demand services that only start when strictly necessary.

---

## **1. The `[Install]` Section and Enabling Units**

In previous sections, you learned how a unit can define its own dependencies (e.g., Unit A says "I want Unit B"). However, Systemd allows you to define dependencies in **reverse**. This is done using the `[Install]` section.

Instead of editing a system file to add a dependency, you edit your custom unit file to say, "I am wanted by that system file." This is the primary mechanism used to make services start at boot time.

### **Key Directives**
*   **`WantedBy=`**: When you enable this unit, Systemd creates a "weak" dependency (symlink) in the target unit.
*   **`RequiredBy=`**: Similar to above, but creates a strict dependency.

### **The Mechanics of "Enabling"**
When you run `systemctl enable`, Systemd reads the `[Install]` section and creates symbolic links (symlinks) in a specific directory ending in `.wants` or `.requires`.

**Important Distinction:**
*   **Starting (`systemctl start`)**: Activates the unit immediately (Runtime).
*   **Enabling (`systemctl enable`)**: Hooks the unit into the boot process or another unit's startup sequence (Configuration). It does not start the unit immediately.

### **Hands-on Example: Reverse Dependencies**

We will create two targets. We will configure `test1` to automatically attach itself to `test2` when enabled.

**Step 1: Create the parent unit (test2).**
This unit is simple and knows nothing about test1.
```bash
sudo nano /etc/systemd/system/test2.target
```
*Content:*
```ini
[Unit]
Description=Test 2 Parent Target
```

**Step 2: Create the child unit (test1) with an Install section.**
This unit tells Systemd: "When I am enabled, hook me into `test2.target`."
```bash
sudo nano /etc/systemd/system/test1.target
```
*Content:*
```ini
[Unit]
Description=Test 1 Child Target

[Install]
WantedBy=test2.target
```

**Step 3: Enable the unit.**
Watch the output carefully. You will see the symbolic link being created.
```bash
sudo systemctl enable test1.target
```
*Output:*
`Created symlink /etc/systemd/system/test2.target.wants/test1.target → /etc/systemd/system/test1.target.`

**Step 4: Verify the effect.**
If you were to start `test2.target` now, it would automatically pull in `test1.target` because of that link.
```bash
sudo systemctl start test2.target
systemctl status test1.target
```
*You will see that `test1.target` is active.*

**Step 5: Disable the unit.**
This removes the symbolic link, severing the dependency.
```bash
sudo systemctl disable test1.target
```
*Output:*
`Removed /etc/systemd/system/test2.target.wants/test1.target.`

---

## **2. Manual Dependency Management**

While `[Install]` sections are the standard way to manage dependencies, the underlying mechanism is simply the existence of directories named `.wants` and `.requires`.

You can manually create symbolic links in these directories in `/etc/systemd/system/`.
*   **Pros:** You can force a dependency without editing unit files (useful if you don't want to touch vendor-supplied files).
*   **Cons:** It is "invisible" configuration. A future system administrator looking at the unit files won't see any text indicating this dependency exists.

---

## **3. On-Demand and Resource-Parallelized Startup**

One of Systemd's most powerful features is **Socket Activation** (and Path/Device activation). This allows a system to boot extremely fast by not starting services until they are actually needed.

### **How it Works**
Instead of a service running in the background consuming memory waiting for a connection, Systemd takes over the listening port.

1.  **The Resource Unit (Unit R):** A `.socket` file tells Systemd to listen on a specific port (e.g., port 80).
2.  **The Monitoring:** Systemd listens on port 80. No web server is running yet.
3.  **The Trigger:** A user connects to port 80. Systemd pauses the connection and buffers the data.
4.  **The Activation:** Systemd starts the actual Service Unit (Unit A).
5.  **The Handoff:** Once Unit A is ready, Systemd hands over the socket and the buffered data. The service processes the request as if it had been listening all along.

### **Types of Resource Units**
*   **Socket Units (`.socket`):** Monitors network ports or IPC sockets.
*   **Path Units (`.path`):** Monitors files or directories for changes.
*   **Device Units (`.device`):** Monitors hardware plugging/unplugging.

### **Hands-on Example: Socket Activation**

We will create a simple "Echo Service" that only starts when you connect to port 12345.

**Step 1: Create the Service Unit.**
Note that we do not specify `WantedBy` here, because the *socket* will start this service, not the boot process.
```bash
sudo nano /etc/systemd/system/my-echo.service
```
*Content:*
```ini
[Unit]
Description=My Echo Service

[Service]
ExecStart=/bin/cat
StandardInput=socket
```

**Step 2: Create the Socket Unit.**
This tells Systemd to listen on port 12345.
```bash
sudo nano /etc/systemd/system/my-echo.socket
```
*Content:*
```ini
[Unit]
Description=Socket for Echo Service

[Socket]
ListenStream=12345
Accept=yes

[Install]
WantedBy=sockets.target
```

**Step 3: Start ONLY the socket.**
Do not start the service.
```bash
sudo systemctl start my-echo.socket
```

**Step 4: Verify the Service is NOT running.**
```bash
systemctl status my-echo.service
```
*Result: It should say `inactive (dead)`.*

**Step 5: Trigger the socket.**
We will connect to the port using `nc` (Netcat). Type anything and press Enter; it should echo back.
*(If you don't have nc, install it via `sudo apt install netcat` or `sudo dnf install nc`)*.
```bash
nc localhost 12345
```
*(Type "Hello", press Enter, then Ctrl+C to exit).*

**Step 6: Check the status again.**
Systemd momentarily spun up an instance of the service to handle your request.
```bash
systemctl list-units --all | grep my-echo
```
*Result: You will see that the socket is active, and you might see a lingering instance of the service that handled your connection.*