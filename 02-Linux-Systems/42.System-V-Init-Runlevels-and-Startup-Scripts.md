# Understanding System V Init, Runlevels, and Startup Scripts

This guide explains the legacy "System V Init" (SysV) process. Although modern systems use **systemd**, understanding SysV is crucial because:
1.  Many concepts (like runlevels) still exist as compatibility layers.
2.  You may encounter legacy servers or embedded devices (routers, IoT) that still use it.
3.  Many software packages still ship with SysV-style scripts.

---

## **1. System V Runlevels**

A **Runlevel** represents the state of the machine. It defines what services are running.

### **The Standard Runlevels**
*   **0:** System Halt (Shutdown).
*   **1 (or S):** Single-user mode (Maintenance mode, no networking).
*   **2-4:** Multi-user mode (Text console only, often without GUI).
*   **5:** Multi-user mode with Graphical User Interface (GUI).
*   **6:** Reboot.

### **Hands-on Example: Checking Runlevels**

Even on a systemd machine, you can check the current "runlevel" (or its systemd equivalent target).

**Step 1: Check current runlevel.**
Open your terminal and type:
```bash
who -r
```
*Output:* You will see something like `run-level 5 2023-10-27 10:00`. This means you are in Graphical Mode.

**Step 2: Check the systemd mapping.**
Systemd maps these old numbers to new "Targets". Run this to see the default target your system boots into:
```bash
systemctl get-default
```
*Output:* `graphical.target` (which corresponds to Runlevel 5) or `multi-user.target` (Runlevel 3).

---

## **2. The `/etc/inittab` File**

In a pure SysV system, the kernel starts `init` (PID 1), and `init` reads `/etc/inittab`. This file controls the entire OS behavior.

**Note:** On modern systemd Linux (Ubuntu 16+, CentOS 7+), this file **does not exist**. We will simulate understanding it by analyzing the syntax.

### **Syntax Breakdown**
Format: `id:runlevels:action:process`

1.  **id**: A unique name (e.g., `l5`).
2.  **runlevels**: When to run this line (e.g., `5` for GUI mode).
3.  **action**: What to do (e.g., `wait` = run once and wait; `respawn` = keep restarting if it dies).
4.  **process**: The command to run.

**Key Example:**
`id:5:initdefault:` → Tells the system to boot into Runlevel 5 by default.
`l5:5:wait:/etc/rc.d/rc 5` → When entering Runlevel 5, run the script `/etc/rc.d/rc` with argument `5`.

### **Hands-on Example: Finding Legacy Traces**

Although `inittab` is gone, the *concept* of `respawn` (automatically restarting a crashed service) is alive in systemd.

**Step 1: Check a modern service for "respawn" behavior.**
Let's look at the `getty` service (the login prompt).
```bash
systemctl cat getty@.service
```
*Look for `Restart=always`. This is the modern equivalent of the SysV `respawn` action.*

---

## **3. The Startup Sequence (`rc` Scripts)**

In SysV, "Services" were just shell scripts located in `/etc/init.d/`.
To manage which services started in which runlevel, the system used directories named `rc0.d`, `rc1.d` ... `rc6.d`.

### **How it works:**
1.  The system enters **Runlevel 5**.
2.  It looks inside `/etc/rc5.d/`.
3.  It finds symbolic links pointing to the actual scripts in `/etc/init.d/`.
4.  It sorts them by filename.
5.  **Starts with 'K'**: It runs the script with `stop` (Kill).
6.  **Starts with 'S'**: It runs the script with `start`.
7.  **The Number**: Determines the order (e.g., `S10network` runs before `S99local`).

### **Hands-on Example: Exploring Legacy Directories**

Most modern distros still keep these directories for compatibility! Let's explore them.

**Step 1: List the scripts in Runlevel 5 (Graphical Mode).**
```bash
ls -l /etc/rc5.d/
```
*Output:* You might see files like `S01saned`, `S01spice-vdagentd`, etc.
*   Notice they are typically colored **Cyan** (indicating they are symbolic links).
*   Notice they point to `../init.d/service_name`.

**Step 2: Simulate the logic.**
If you see a file named `S01bluetooth` linked to `../init.d/bluetooth`, the legacy init system would execute:
`/etc/init.d/bluetooth start`

**Step 3: Manually interacting with a legacy script.**
If your system has any scripts in `/etc/init.d/`, you can often run them directly.
```bash
ls /etc/init.d/
```
*Pick a safe one, like `cron` or `bluetooth`. (Note: `systemctl` usually redirects these commands now).*
```bash
/etc/init.d/cron status
```
*This is how administrators managed services for 20 years before systemctl.*

---

## **4. Summary Table: SysV vs. Systemd**

| Feature | System V Init | Systemd |
| :--- | :--- | :--- |
| **Config File** | `/etc/inittab` | Unit files (`.service`, `.target`) |
| **Boot Scripts** | `/etc/init.d/script_name` | `ExecStart=` inside Unit file |
| **Runlevels** | `0` - `6` | Targets (`poweroff.target`, `graphical.target`) |
| **Enabling** | Creating Symlinks in `rcX.d` | `systemctl enable` (creates symlinks in `.wants`) |
| **Ordering** | `S01`, `S99` (Filename sort) | `After=`, `Before=` (Dependency graph) |

---

## **5. Compatibility**

If you install an old software package that only includes a SysV init script (in `/etc/init.d/`), systemd is smart enough to handle it.
1.  Systemd notices the script.
2.  It generates a temporary "wrapper" service unit on the fly.
3.  It maps `S99` to `After=` dependencies.
4.  This allows you to use `systemctl start old_service` even though the software doesn't natively support systemd.