# Understanding System V Init, Runlevels, and Startup Scripts

This guide explains the legacy "System V Init" (SysV) process. Although modern systems use **systemd**, understanding SysV is crucial because:
1.  Many concepts (like runlevels) still exist as compatibility layers.
2.  You may encounter legacy servers or embedded devices (routers, IoT) that still use it.
3.  Many software packages still ship with SysV-style scripts.

---

## **1. System V Runlevels**

A **Runlevel** represents the state of the machine. It defines what services are running.

### **The Standard Runlevels**
*   **0:** System Halt (Shutdown).
*   **1 (or S):** Single-user mode (Maintenance mode, no networking).
*   **2-4:** Multi-user mode (Text console only, often without GUI).
*   **5:** Multi-user mode with Graphical User Interface (GUI).
*   **6:** Reboot.

### **Hands-on Example: Checking Runlevels**

Even on a systemd machine, you can check the current "runlevel" (or its systemd equivalent target).

**Step 1: Check current runlevel.**
Open your terminal and type:
```bash
who -r
```
*Output:* You will see something like `run-level 5 2023-10-27 10:00`. This means you are in Graphical Mode.

**Step 2: Check the systemd mapping.**
Systemd maps these old numbers to new "Targets". Run this to see the default target your system boots into:
```bash
systemctl get-default
```
*Output:* `graphical.target` (which corresponds to Runlevel 5) or `multi-user.target` (Runlevel 3).

---

## **2. The `/etc/inittab` File**

In a pure SysV system, the kernel starts `init` (PID 1), and `init` reads `/etc/inittab`. This file controls the entire OS behavior.

**Note:** On modern systemd Linux (Ubuntu 16+, CentOS 7+), this file **does not exist**. We will simulate understanding it by analyzing the syntax.

### **Syntax Breakdown**
Format: `id:runlevels:action:process`

1.  **id**: A unique name (e.g., `l5`).
2.  **runlevels**: When to run this line (e.g., `5` for GUI mode).
3.  **action**: What to do (e.g., `wait` = run once and wait; `respawn` = keep restarting if it dies).
4.  **process**: The command to run.

**Key Example:**
`id:5:initdefault:` → Tells the system to boot into Runlevel 5 by default.
`l5:5:wait:/etc/rc.d/rc 5` → When entering Runlevel 5, run the script `/etc/rc.d/rc` with argument `5`.

### **Hands-on Example: Finding Legacy Traces**

Although `inittab` is gone, the *concept* of `respawn` (automatically restarting a crashed service) is alive in systemd.

**Step 1: Check a modern service for "respawn" behavior.**
Let's look at the `getty` service (the login prompt).
```bash
systemctl cat getty@.service
```
*Look for `Restart=always`. This is the modern equivalent of the SysV `respawn` action.*

---

## **3. The Startup Sequence (`rc` Scripts)**

In SysV, "Services" were just shell scripts located in `/etc/init.d/`.
To manage which services started in which runlevel, the system used directories named `rc0.d`, `rc1.d` ... `rc6.d`.

### **How it works:**
1.  The system enters **Runlevel 5**.
2.  It looks inside `/etc/rc5.d/`.
3.  It finds symbolic links pointing to the actual scripts in `/etc/init.d/`.
4.  It sorts them by filename.
5.  **Starts with 'K'**: It runs the script with `stop` (Kill).
6.  **Starts with 'S'**: It runs the script with `start`.
7.  **The Number**: Determines the order (e.g., `S10network` runs before `S99local`).

### **Hands-on Example: Exploring Legacy Directories**

Most modern distros still keep these directories for compatibility! Let's explore them.

**Step 1: List the scripts in Runlevel 5 (Graphical Mode).**
```bash
ls -l /etc/rc5.d/
```
*Output:* You might see files like `S01saned`, `S01spice-vdagentd`, etc.
*   Notice they are typically colored **Cyan** (indicating they are symbolic links).
*   Notice they point to `../init.d/service_name`.

**Step 2: Simulate the logic.**
If you see a file named `S01bluetooth` linked to `../init.d/bluetooth`, the legacy init system would execute:
`/etc/init.d/bluetooth start`

**Step 3: Manually interacting with a legacy script.**
If your system has any scripts in `/etc/init.d/`, you can often run them directly.
```bash
ls /etc/init.d/
```
*Pick a safe one, like `cron` or `bluetooth`. (Note: `systemctl` usually redirects these commands now).*
```bash
/etc/init.d/cron status
```
*This is how administrators managed services for 20 years before systemctl.*

---

## **4. Summary Table: SysV vs. Systemd**

| Feature | System V Init | Systemd |
| :--- | :--- | :--- |
| **Config File** | `/etc/inittab` | Unit files (`.service`, `.target`) |
| **Boot Scripts** | `/etc/init.d/script_name` | `ExecStart=` inside Unit file |
| **Runlevels** | `0` - `6` | Targets (`poweroff.target`, `graphical.target`) |
| **Enabling** | Creating Symlinks in `rcX.d` | `systemctl enable` (creates symlinks in `.wants`) |
| **Ordering** | `S01`, `S99` (Filename sort) | `After=`, `Before=` (Dependency graph) |

---

## **5. Compatibility**

If you install an old software package that only includes a SysV init script (in `/etc/init.d/`), systemd is smart enough to handle it.
1.  Systemd notices the script.
2.  It generates a temporary "wrapper" service unit on the fly.
3.  It maps `S99` to `After=` dependencies.
4.  This allows you to use `systemctl start old_service` even though the software doesn't natively support systemd.

    # Legacy System V Init: Link Farms, Service Control, and Systemd Compatibility
     
    Now let's dive into how the traditional Linux boot system works (System V Init). Even though modern systems use `systemd`, understanding the legacy "Link Farm" structure is essential for troubleshooting older servers, understanding boot sequences, and managing legacy scripts that systemd still supports.
     
    ---
     
    ## **1. The System V Link Farm**
     
    The "Link Farm" is a clever way of organizing which scripts run at which time without duplicating files.
     
    *   **The Source:** All actual service scripts live in one central directory: `/etc/init.d/`.
    *   **The Triggers:** Each runlevel (state of the machine) has its own directory: `/etc/rc0.d/` through `/etc/rc6.d/`.
    *   **The Links:** Inside these directories are **Symbolic Links** pointing back to the central scripts.
     
    ### **The Naming Convention**
    The filename of the link tells the system *what* to do and *when* to do it.
    *   **Start with 'S':** Start the service.
    *   **Start with 'K':** Kill (Stop) the service.
    *   **The Number (00-99):** The order. `S10network` runs before `S99httpd` because you need the network before the web server.
     
    ### **Hands-on Example: Investigating the Link Farm**
     
    Let's look at how your system organizes these files. Even on modern systemd machines, these directories often exist for backward compatibility.
     
    **Step 1: List the actual scripts.**
    ```bash
    ls -F /etc/init.d/
    ```
    *Output:* You will see green executable scripts (e.g., `cron`, `networking`, `procps`).
     
    **Step 2: Investigate a Runlevel Directory.**
    Let's see what happens when the computer enters Graphical Mode (Runlevel 5).
    ```bash
    ls -l /etc/rc5.d/
    ```
    *Output:* Look for the arrows `->`.
    `lrwxrwxrwx ... S01cron -> ../init.d/cron`
     
    This tells us: "When entering level 5, run `/etc/init.d/cron start` very early (01)."
     
    ---
     
    ## **2. Modifying the Boot Sequence (The "Old School" Way)**
     
    In the past, to disable a service from starting at boot, you didn't have a command like `systemctl disable`. You had to manually rename or remove the link.
     
    ### **The Safe Disable Method**
    Instead of deleting the link (which makes it hard to remember what was there), you rename it so it no longer starts with `S` or `K`.
     
    **Hands-on Example: Simulating a Disable**
     
    **Warning:** Do not do this to critical system services. We will simulate with a dummy file.
     
    1.  **Create a dummy script:**
        ```bash
        sudo touch /etc/init.d/dummy-service
        sudo chmod +x /etc/init.d/dummy-service
        ```
     
    2.  **Create a Start link (Simulating "Enable"):**
        ```bash
        sudo ln -s /etc/init.d/dummy-service /etc/rc5.d/S99dummy
        ```
     
    3.  **Verify it exists:**
        ```bash
        ls -l /etc/rc5.d/S99dummy
        ```
     
    4.  **Disable it (The Rename Trick):**
        We rename `S99` to `_S99`. The boot system ignores files starting with `_`.
        ```bash
        sudo mv /etc/rc5.d/S99dummy /etc/rc5.d/_S99dummy
        ```
     
    5.  **Clean up:**
        ```bash
        sudo rm /etc/init.d/dummy-service /etc/rc5.d/_S99dummy
        ```
     
    ---
     
    ## **3. `run-parts`: The Engine Behind the Scenes**
     
    The utility `run-parts` is a simple tool that executes all scripts found in a directory.
     
    *   It checks the filename rules (must look like a valid script name).
    *   It executes them in alphabetical/numerical order.
    *   It is used by `cron` (to run `/etc/cron.daily/`) and by legacy init systems.
     
    **Hands-on Example: Using `run-parts`**
     
    1.  **Create a test directory:**
        ```bash
        mkdir test-parts
        ```
    2.  **Create two scripts inside:**
        ```bash
        echo -e '#!/bin/bash\necho "I am Script 1"' > test-parts/01script
        echo -e '#!/bin/bash\necho "I am Script 2"' > test-parts/02script
        chmod +x test-parts/*
        ```
    3.  **Run them all at once:**
        ```bash
        run-parts --verbose test-parts
        ```
        *Output:* You will see it execute `01script` then `02script`.
     
    4.  **Clean up:**
        ```bash
        rm -r test-parts
        ```
     
    ---
     
    ## **4. Controlling Init with `telinit`**
     
    The command `telinit` (Tell Init) is used to switch runlevels immediately.
     
    *   `telinit 0`: Halt the system (Shutdown).
    *   `telinit 1` (or `s`): Switch to Single User Mode (Emergency/Maintenance).
    *   `telinit 6`: Reboot.
    *   `telinit q`: Reload `/etc/inittab` configuration.
     
    **Note:** On modern systemd systems, `telinit` is just a shortcut (symlink) to `systemctl`. Typing `telinit 6` actually runs `systemctl reboot`.
     
    ---
     
    ## **5. Systemd Compatibility Mode**
     
    Systemd is designed to replace System V, but it doesn't break it. If you have an old application that installs a script to `/etc/init.d/legacy-app`, systemd automatically wraps it.
     
    ### **How Systemd Handles Legacy Scripts**
     
    1.  **Detection:** Systemd sees `/etc/init.d/legacy-app`.
    2.  **Translation:** It creates a "Wrapper Unit" in memory called `legacy-app.service`.
    3.  **Mapping:**
        *   Running `systemctl start legacy-app` → executes `/etc/init.d/legacy-app start`.
        *   Running `systemctl stop legacy-app` → executes `/etc/init.d/legacy-app stop`.
    4.  **Status:** Even though it's an old script, `systemctl status legacy-app` will show you the output and the PIDs it spawned.
     
    **Hands-on Example: The Wrapper**
     
    Let's see if your system has any generated units.
     
    ```bash
    systemctl list-units --type=service --all | grep "rc-local"
    ```
    *Many systems use `rc-local.service`. This is often a compatibility wrapper for the old `/etc/rc.local` script.*
     
    You can also check the status of a pure legacy script if one exists (like `cron` or `networking` on some distros):
    ```bash
    systemctl status cron
    ```
    *Even if `cron` uses an old init script, systemd wraps it and shows the status beautifully.*
