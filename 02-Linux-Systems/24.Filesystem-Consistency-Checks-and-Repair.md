# System Maintenance: Filesystem Consistency Checks and Repair

## Introduction
A filesystem is essentially a complex database that tracks where your data physically sits on a storage device. If a computer loses power suddenly or crashes, this database can become desynchronized (e.g., the system thinks it wrote a file, but the data never actually hit the disk).

To prevent data loss, Linux provides the **`fsck`** (File System Consistency Check) utility. This tool acts like a doctor for your hard drive: it scans the structure, identifies logical errors, and attempts to repair them.

---

## Part 1: The Golden Rule of `fsck`

There is one critical rule you must remember before running this command:

### **WARNING**
$$ \text{NEVER run } \texttt{fsck} \text{ on a mounted, read-write filesystem!} $$

If you repair a filesystem while the Operating System is actively writing to it, you will likely cause severe data corruption.
*   **Correct Way:** Unmount the disk first (`umount /dev/sdb1`).
*   **Exception:** If you are in Single-User Mode and the root partition is mounted as **Read-Only**, you may check it.

---

## Part 2: How `fsck` Works

The `fsck` command is actually a "wrapper" (a frontend). It detects the filesystem type (like `ext4`) and calls the specific tool for that job (e.g., `e2fsck`).

### 2.1 The Scan Passes
When `fsck` runs, it performs 5 distinct passes (checks):
1.  **Inodes, blocks, and sizes:** Checks the file metadata "ID cards."
2.  **Directory structure:** Ensures folders are linked correctly.
3.  **Directory connectivity:** Ensures no folder is isolated from the tree.
4.  **Reference counts:** Ensures the number of links to a file matches the database.
5.  **Group summary information:** Checks the block bitmaps.

### 2.2 Operation Modes

**1. Manual (Interactive) Mode:**
$$ \texttt{fsck /dev/sdb1} $$
If errors are found, the system stops and asks you what to do (e.g., "Fix? [y/n]").
*   *Orphaned Files:* If `fsck` finds data but doesn't know the filename, it moves the file to the `lost+found` directory in the root of that partition. It renames them with their Inode number (e.g., `#12455`). You must inspect these manually to identify them.

**2. Automatic "Preen" Mode:**
$$ \texttt{fsck -p /dev/sdb1} $$
This safely fixes minor errors (like timestamps) without bothering you. If it finds a major error, it stops and requires manual intervention.

**3. Force "Yes" Mode:**
$$ \texttt{fsck -y /dev/sdb1} $$
This answers "Yes" to every question. Use this only if you have hundreds of errors and don't care about potentially losing some individual file integrity to save the whole disk.

**4. Check-Only (Dry Run):**
$$ \texttt{fsck -n /dev/sdb1} $$
This scans the disk and reports errors but **does not write** any changes. This is safe to run even if you aren't sure about the disk status.

---

## Part 3: Advanced Recovery (Superblocks and Journals)

### 3.1 The Superblock
The **Superblock** is the most critical metadata on the drive. It defines the filesystem parameters. If this is corrupted, the drive appears to be unformatted or empty.
Fortunately, `mkfs` creates backups of the superblock at different locations when the drive is first formatted.

**How to find backup locations:**
$$ \texttt{mkfs -n /dev/sdb1} $$
*(Note the `-n`: This simulates formatting to show you where the backups would be, without actually erasing data.)*

**How to restore from backup:**
$$ \texttt{fsck -b [block\_number] /dev/sdb1} $$

### 3.2 Journaling (ext3 / ext4)
Modern filesystems keep a "Journal" (a log of intended changes). If the power fails, the system usually just "replays" the journal to fix itself automatically.
To force a journal flush and repair on an ext4 disk:
$$ \texttt{e2fsck -fy /dev/sdb1} $$

### 3.3 The Last Resort: `debugfs`
If `fsck` fails, you can use `debugfs`. This is an interactive shell that lets you manually navigate a corrupted filesystem to copy files out before you format the drive.

---

## Part 4: Hands-on Lab (GitHub Codespaces)

In this lab, we will create a virtual drive, deliberately corrupt its Superblock (simulation of a disaster), and then use `fsck` to repair it using a backup.

### Step 1: Create and Format a Disk Image
We create a 100MB file and format it as ext4.

```bash
# 1. Create the image file
dd if=/dev/zero of=repair_disk.img bs=1M count=100

# 2. Format it (and save the output!)
# We use 'tee' to see the output on screen AND save it to a log file
mkfs.ext4 -F repair_disk.img | tee format.log
```

### Step 2: Inspect the Superblock Backups
Look at the output from the previous command (or the log file). You will see lines like:
`Superblock backups stored on blocks: 32768, 98304...`

Let's assume the first backup is at **32768**. We will need this later.

### Step 3: Populate the Disk
We mount it and add a file so we have data to "save."

```bash
# Create mount point
mkdir my_data

# Mount
sudo mount repair_disk.img my_data

# Write a file
sudo sh -c 'echo "This is critical data that must be saved." > my_data/secret.txt'

# Verify
ls -l my_data/
```

### Step 4: Simulate Corruption
Now we will break the drive. We unmount it, then use `dd` to overwrite the beginning of the drive (where the main Superblock lives) with zeros.

```bash
# 1. Unmount (Vital step!)
sudo umount my_data

# 2. Corrupt the first 4KB (The Primary Superblock area)
# conv=notrunc means "don't delete the rest of the file"
dd if=/dev/zero of=repair_disk.img bs=4096 count=1 conv=notrunc
```

### Step 5: Verify the Damage
Try to check the disk normally. It should fail because the header is gone.

```bash
# Try a normal check
fsck.ext4 -n repair_disk.img
```
**Observation:** You should see an error like `Bad magic number in super-block` or `Could not find valid filesystem`. The system thinks the disk is empty.

### Step 6: The Repair (Using Backup Superblock)
We know (from Step 2) that a backup exists at block **32768**. We will tell `fsck` to use that one instead of the broken one at block 0.

```bash
# Replace 32768 with the number you saw in Step 2 if it was different.
# -b tells fsck to use a backup.
# -y tells fsck to answer "yes" to fixing the primary superblock.

fsck.ext4 -b 32768 -y repair_disk.img
```
**Observation:** It should say `Fix? yes`. It will copy the backup over the zeros we wrote.

### Step 7: Verify Data Recovery
Now that `fsck` says it is clean, let's mount it and see if our text file survived.

```bash
# Mount
sudo mount repair_disk.img my_data

# Check file
cat my_data/secret.txt
```
**Result:** You should see `"This is critical data that must be saved."`

### Step 8: Clean Up
```bash
sudo umount my_data
rm repair_disk.img format.log
rmdir my_data
```