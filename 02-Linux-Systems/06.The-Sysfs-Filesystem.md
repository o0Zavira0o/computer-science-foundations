# The Sysfs Filesystem (`/sys`): The Kernel's Dashboard

In the previous section, we learned about $/\texttt{dev}$.
*   **$/\texttt{dev}$** is like a **Steering Wheel**. It provides a handle to *use* the device (read/write data).

Now, we meet **$/\texttt{sys}$** (or **sysfs**).
*   **$/\texttt{sys}$** is like the **Dashboard/Engine Diagnostics**. It provides *information* about the device (status, model name, connection path, size).

The problem with `/dev` is that it is disorganized. It just lists devices in the order they were found. `/sys`, on the other hand, organizes devices based on exactly how they are physically (or logically) connected to the computer hardware.

---

## 1. The Structure: A Map of Hardware
The paths in `/sys` can look terrifyingly long.
Example:
$$ \texttt{/sys/devices/pci0000:00/.../target0:0:0/block/sda} $$

**Why is it so long?**
This path traces the actual electrical connection from the CPU $\rightarrow$ PCI Bus $\rightarrow$ Storage Controller $\rightarrow$ The Cable $\rightarrow$ The Hard Drive.

While `/dev/sda` is just a filename, the `/sys` path tells the computer exactly *where* that drive is located physically.

## 2. Files as "Attributes"
If you navigate into one of these folders, you will see many small files. These are not documents; they are **attributes**.

*   **Reading:** If you run `cat size` inside a disk folder in `/sys`, the kernel tells you the size of the disk.
*   **Writing:** (Advanced) If you write a value to specific files in `/sys`, you can actually change hardware settings on the fly (like changing screen brightness or turning off a USB port).

## 3. Shortcuts: `/sys/block` and `/sys/class`
Because navigating those long PCI paths is painful, Linux provides shortcuts using **Symbolic Links**.

*   **$/\texttt{sys/block}$:** Contains shortcuts to all storage devices (disks, loop devices).
*   **$/\texttt{sys/class}$:** Groups devices by function (e.g., "Sound", "Net", "Input") regardless of where they are plugged in.

## 4. The Translator: `udevadm`
How do you find the complex `/sys` path if you only know the simple name `/dev/sda`? You use the **udevadm** command.

$$ \texttt{udevadm info --query=all --name=/dev/sda} $$

This queries the database and tells you everything the kernel knows about that device.

---

# üõ†Ô∏è Hands-On Lab: GitHub Codespaces

Since Codespaces runs in a virtual container, you don't have physical hard drives connected via cables. However, you *do* have virtual network cards and system files. We will use those to explore `/sys`.

### Step 1: Using the Shortcuts (`/sys/class`)
Let's find your network adapter without digging through complex hardware paths.

```bash
# 1. List the categories of devices
ls -F /sys/class/
```
**Observation:** You will see categories like `net/`, `input/`, `mem/`.

```bash
# 2. Look inside the 'net' (Network) folder
ls -l /sys/class/net/
```
**Observation:** You will see entries like `eth0` or `docker0`. Notice the arrow ($\rightarrow$). These are shortcuts pointing to the deep, complex physical paths!

### Step 2: Reading Device Attributes
Let's ask the Kernel for details about your network card (`eth0`) by reading files in `/sys`.

```bash
# 1. Go into the folder for the first network card
cd /sys/class/net/eth0

# 2. List the available attributes
ls

# 3. Read the MAC address (physical address)
cat address

# 4. Check the operational state (is it working?)
cat operstate
```
**Result:** You just read hardware details directly from the Kernel memory without using any special tools, just `cat`!

### Step 3: Comparing `/dev` and `/sys`
Let's look at the "loop" devices (virtual disks used by the system).

```bash
# 1. Look at the 'dev' file inside sysfs
cat /sys/class/block/loop0/dev
```
**Result:** You might see something like `7:0`.
This corresponds to the Major:Minor numbers we learned about in the previous chapter. It links the `/sys` entry back to the `/dev` entry.

### Step 4: Using `udevadm`
Let's use the professional tool to get a full report on a device.

```bash
# Ask udevadm for info about the loop0 device
udevadm info --query=all --name=/dev/loop0
```
**Result:** You will see a large block of text labeled `P:` (Path), `N:` (Name), and `E:` (Environment variables). This is the data the system uses to automatically configure the device when it is "plugged in."